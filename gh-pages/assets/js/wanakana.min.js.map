{"version":3,"file":"wanakana.min.js","sources":["../../src/utils/typeOf.js","../../src/utils/isEmpty.js","../../src/utils/isCharInRange.js","../../src/utils/isCharJapanese.js","../../src/isJapanese.js","../../src/utils/kanaMapping.js","../../src/utils/romajiToKanaMap.js","../../src/utils/isCharUpperCase.js","../../src/utils/isCharLongDash.js","../../src/utils/isCharSlashDot.js","../../src/utils/isCharHiragana.js","../../src/utils/hiraganaToKatakana.js","../../src/toKana.js","../../src/utils/dom.js","../../src/bind.js","../../src/unbind.js","../../src/utils/isCharRomaji.js","../../src/isRomaji.js","../../src/utils/isCharKatakana.js","../../src/utils/isCharKana.js","../../src/isKana.js","../../src/isHiragana.js","../../src/isKatakana.js","../../src/utils/isCharKanji.js","../../src/isKanji.js","../../src/isMixed.js","../../src/utils/katakanaToHiragana.js","../../src/utils/romajiToHiragana.js","../../src/utils/isCharEnglishPunctuation.js","../../src/toHiragana.js","../../src/utils/kanaToRomajiMap.js","../../src/toRomaji.js","../../src/toKatakana.js","../../src/utils/isCharJapanesePunctuation.js","../../src/utils/isCharPunctuation.js","../../src/stripOkurigana.js","../../src/tokenize.js","../../src/constants.js","../../src/utils/mergeWithDefaultOptions.js","../../src/utils/logInputEvents.js"],"sourcesContent":["/**\n * Returns detailed type as string (instead of just 'object' for arrays etc)\n * @ignore\n * @param {any} value js value\n * @returns {String} type of value\n * @example\n * typeOf({}); // 'object'\n * typeOf([]); // 'array'\n * typeOf(function() {}); // 'function'\n * typeOf(/a/); // 'regexp'\n * typeOf(new Date()); // 'date'\n * typeOf(null); // 'null'\n * typeOf(undefined); // 'undefined'\n * typeOf('a'); // 'string'\n * typeOf(1); // 'number'\n * typeOf(true); // 'boolean'\n * typeOf(new Map()); // 'map'\n * typeOf(new Set()); // 'map'\n */\nfunction typeOf(value) {\n  if (value === null) {\n    return 'null';\n  }\n  if (value !== Object(value)) {\n    return typeof value;\n  }\n  return {}.toString\n    .call(value)\n    .slice(8, -1)\n    .toLowerCase();\n}\n\nexport default typeOf;\n","import typeOf from './typeOf';\n/**\n * Checks if input string is empty\n * @param  {String} input text input\n * @return {Boolean} true if no input\n */\nfunction isEmpty(input) {\n  if (typeOf(input) !== 'string') {\n    return true;\n  }\n  return !input.length;\n}\n\nexport default isEmpty;\n","import isEmpty from './isEmpty';\n\n/**\n * Takes a character and a unicode range. Returns true if the char is in the range.\n * @param  {String}  char  unicode character\n * @param  {Number}  start unicode start range\n * @param  {Number}  end   unicode end range\n * @return {Boolean}\n */\nfunction isCharInRange(char = '', start, end) {\n  if (isEmpty(char)) return false;\n  const code = char.charCodeAt(0);\n  return start <= code && code <= end;\n}\n\nexport default isCharInRange;\n","import isCharInRange from './isCharInRange';\nimport { JAPANESE_RANGES } from '../constants';\n\n/**\n * Tests a character. Returns true if the character is [Katakana](https://en.wikipedia.org/wiki/Katakana).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharJapanese(char = '') {\n  return JAPANESE_RANGES.some(([start, end]) => isCharInRange(char, start, end));\n}\n\nexport default isCharJapanese;\n","import typeOf from './utils/typeOf';\nimport isEmpty from './utils/isEmpty';\nimport isCharJapanese from './utils/isCharJapanese';\n\n/**\n * Test if `input` only includes [Kanji](https://en.wikipedia.org/wiki/Kanji), [Kana](https://en.wikipedia.org/wiki/Kana), zenkaku numbers, and JA punctuation/symbols.”\n * @param  {String} [input=''] text\n * @param  {Regexp} [allowed] additional test allowed to pass for each char\n * @return {Boolean} true if passes checks\n * @example\n * isJapanese('泣き虫')\n * // => true\n * isJapanese('あア')\n * // => true\n * isJapanese('２月') // Zenkaku numbers allowed\n * // => true\n * isJapanese('泣き虫。！〜＄') // Zenkaku/JA punctuation\n * // => true\n * isJapanese('泣き虫.!~$') // Latin punctuation fails\n * // => false\n * isJapanese('A泣き虫')\n * // => false\n * isJapanese('≪偽括弧≫', /[≪≫]/);\n * // => true\n */\nfunction isJapanese(input = '', allowed) {\n  const augmented = typeOf(allowed) === 'regexp';\n  return isEmpty(input)\n    ? false\n    : [...input].every((char) => {\n      const isJa = isCharJapanese(char);\n      return !augmented ? isJa : isJa || allowed.test(char);\n    });\n}\n\nexport default isJapanese;\n","import typeOf from './typeOf';\n\nexport function applyMapping(string, mapping, convertEnding) {\n  const root = mapping;\n  function nextSubtree(tree, nextChar) {\n    const subtree = tree[nextChar];\n    if (subtree === undefined) {\n      return undefined;\n    }\n    // if the next child node does not have a node value, set its node value to the input\n    return Object.assign({ '': tree[''] + nextChar }, tree[nextChar]);\n  }\n\n  function newChunk(remaining, currentCursor) {\n    // start parsing a new chunk\n    const firstChar = remaining.charAt(0);\n\n    return parse(\n      Object.assign({ '': firstChar }, root[firstChar]),\n      remaining.slice(1),\n      currentCursor,\n      currentCursor + 1\n    );\n  }\n\n  function parse(tree, remaining, lastCursor, currentCursor) {\n    if (!remaining) {\n      if (convertEnding || Object.keys(tree).length === 1) {\n        // nothing more to consume, just commit the last chunk and return it\n        // so as to not have an empty element at the end of the result\n        return tree[''] ? [[lastCursor, currentCursor, tree['']]] : [];\n      }\n      // if we don't want to convert the ending, because there are still possible continuations left, just return null as the final node value\n      return [[lastCursor, currentCursor, null]];\n    }\n\n    if (Object.keys(tree).length === 1) {\n      return [[lastCursor, currentCursor, tree['']]].concat(newChunk(remaining, currentCursor));\n    }\n\n    const subtree = nextSubtree(tree, remaining.charAt(0));\n    if (subtree === undefined) {\n      return [[lastCursor, currentCursor, tree['']]].concat(newChunk(remaining, currentCursor));\n    }\n\n    // continue current branch\n    return parse(subtree, remaining.slice(1), lastCursor, currentCursor + 1);\n  }\n  return newChunk(string, 0);\n}\n\n// transform the tree, so that for example hepburnTree['ゔ']['ぁ'][''] === 'va'\n// or kanaTree['k']['y']['a'][''] === 'きゃ'\nexport function transform(tree) {\n  const result = {};\n  for (const [char, subtree] of Object.entries(tree)) {\n    if (typeOf(subtree) === 'string') {\n      // we have reached the bottom of this branch\n      result[char] = { '': subtree };\n    } else {\n      // more subtrees to go through\n      result[char] = transform(subtree);\n    }\n  }\n  return result;\n}\n\nexport function getSubTreeOf(tree, string) {\n  let correctSubTree = tree;\n  for (const char of string) {\n    if (correctSubTree[char] === undefined) {\n      correctSubTree[char] = {};\n    }\n    correctSubTree = correctSubTree[char];\n  }\n  return correctSubTree;\n}\n\n/**\n * Creates a custom mapping tree, returns a function that accepts a defaultMap which the newly created customMapping will be merged with and returned\n * (customMap) => (defaultMap) => mergedMap\n * @param  {Object} customMap { 'ka' : 'な' }\n * @return {Function} (defaultMap) => defaultMergedWithCustomMap\n * @example\n * const sillyMap = createCustomMapping({ 'ちゃ': 'time', '茎': 'cookie'　});\n * // sillyMap is passed defaultMapping to merge with when called in toRomaji()\n * toRomaji(\"It's 茎 ちゃ よ\", { customRomajiMapping: sillyMap });\n * // => 'It's cookie time yo';\n */\nexport function createCustomMapping(customMap = {}) {\n  const customTree = {};\n\n  if (typeOf(customMap) === 'object') {\n    for (const [rom, kan] of Object.entries(customMap)) {\n      let subTree = customTree;\n      for (const char of rom) {\n        if (subTree[char] === undefined) {\n          subTree[char] = {};\n        }\n        subTree = subTree[char];\n      }\n      subTree[''] = kan;\n    }\n  }\n\n  return function makeMap(map) {\n    const mapCopy = JSON.parse(JSON.stringify(map));\n    function transformMap(mapSubtree, customSubtree) {\n      // replace the subtree\n      if (mapSubtree === undefined || typeOf(mapSubtree) === 'string') {\n        return customSubtree;\n      }\n      const result = mapSubtree;\n      for (const [char, subtree] of Object.entries(customSubtree)) {\n        result[char] = transformMap(mapSubtree[char], subtree);\n      }\n      return result;\n    }\n    return transformMap(mapCopy, customTree);\n  };\n}\n\n// allow consumer to pass either function or object as customMapping\nexport function mergeCustomMapping(map = {}, customMapping = {}) {\n  if (typeOf(customMapping) === 'function') {\n    return customMapping(map);\n  } else if (typeOf(customMapping) === 'object') {\n    return createCustomMapping(customMapping)(map);\n  }\n  return map;\n}\n","import { transform, getSubTreeOf, createCustomMapping } from './kanaMapping';\n\nlet romajiToKanaMap = null;\n\nfunction createRomajiToKanaMap() {\n  // not exactly kunrei shiki, for example ぢゃ -> dya instead of zya, to avoid name clashing\n  const kunreiTree = {\n    a: 'あ',\n    i: 'い',\n    u: 'う',\n    e: 'え',\n    o: 'お',\n    k: {\n      a: 'か',\n      i: 'き',\n      u: 'く',\n      e: 'け',\n      o: 'こ',\n    },\n    s: {\n      a: 'さ',\n      i: 'し',\n      u: 'す',\n      e: 'せ',\n      o: 'そ',\n    },\n    t: {\n      a: 'た',\n      i: 'ち',\n      u: 'つ',\n      e: 'て',\n      o: 'と',\n    },\n    n: {\n      a: 'な',\n      i: 'に',\n      u: 'ぬ',\n      e: 'ね',\n      o: 'の',\n    },\n    h: {\n      a: 'は',\n      i: 'ひ',\n      u: 'ふ',\n      e: 'へ',\n      o: 'ほ',\n    },\n    m: {\n      a: 'ま',\n      i: 'み',\n      u: 'む',\n      e: 'め',\n      o: 'も',\n    },\n    y: { a: 'や', u: 'ゆ', o: 'よ' },\n    r: {\n      a: 'ら',\n      i: 'り',\n      u: 'る',\n      e: 'れ',\n      o: 'ろ',\n    },\n    w: {\n      a: 'わ',\n      i: 'ゐ',\n      e: 'ゑ',\n      o: 'を',\n    },\n    g: {\n      a: 'が',\n      i: 'ぎ',\n      u: 'ぐ',\n      e: 'げ',\n      o: 'ご',\n    },\n    z: {\n      a: 'ざ',\n      i: 'じ',\n      u: 'ず',\n      e: 'ぜ',\n      o: 'ぞ',\n    },\n    d: {\n      a: 'だ',\n      i: 'ぢ',\n      u: 'づ',\n      e: 'で',\n      o: 'ど',\n    },\n    b: {\n      a: 'ば',\n      i: 'び',\n      u: 'ぶ',\n      e: 'べ',\n      o: 'ぼ',\n    },\n    p: {\n      a: 'ぱ',\n      i: 'ぴ',\n      u: 'ぷ',\n      e: 'ぺ',\n      o: 'ぽ',\n    },\n\n    v: {\n      a: 'ゔぁ',\n      i: 'ゔぃ',\n      u: 'ゔ',\n      e: 'ゔぇ',\n      o: 'ゔぉ',\n    },\n  };\n\n  const kanaTree = transform(kunreiTree);\n  // pseudo partial application\n  const subtreeOf = (string) => getSubTreeOf(kanaTree, string);\n\n  const consonants = {\n    k: 'き',\n    s: 'し',\n    t: 'ち',\n    n: 'に',\n    h: 'ひ',\n    m: 'み',\n    r: 'り',\n    g: 'ぎ',\n    z: 'じ',\n    d: 'ぢ',\n    b: 'び',\n    p: 'ぴ',\n\n    v: 'ゔ',\n    q: 'く',\n    f: 'ふ',\n  };\n\n  const smallY = {\n    ya: 'ゃ',\n    yi: 'ぃ',\n    yu: 'ゅ',\n    ye: 'ぇ',\n    yo: 'ょ',\n  };\n  const smallaiueo = {\n    a: 'ぁ',\n    i: 'ぃ',\n    u: 'ぅ',\n    e: 'ぇ',\n    o: 'ぉ',\n  };\n\n  // add tya, sya, etc.\n  for (const [consonant, yKana] of Object.entries(consonants)) {\n    for (const [rom, kan] of Object.entries(smallY)) {\n      // for example kyo -> き + ょ\n      subtreeOf(consonant + rom)[''] = yKana + kan;\n    }\n  }\n\n  const specialSymbols = {\n    '.': '。',\n    ',': '、',\n    ':': '：',\n    '/': '・',\n    '!': '！',\n    '?': '？',\n    '~': '〜',\n    '-': 'ー',\n    '‘': '「',\n    '’': '」',\n    '“': '『',\n    '”': '』',\n    '[': '［',\n    ']': '］',\n    '(': '（',\n    ')': '）',\n    '{': '｛',\n    '}': '｝',\n  };\n\n  for (const [symbol, jsymbol] of Object.entries(specialSymbols)) {\n    subtreeOf(symbol)[''] = jsymbol;\n  }\n\n  const aiueoConstructions = {\n    wh: 'う',\n    qw: 'く',\n    q: 'く',\n    gw: 'ぐ',\n    sw: 'す',\n    ts: 'つ',\n    th: 'て',\n    tw: 'と',\n    dh: 'で',\n    dw: 'ど',\n    fw: 'ふ',\n    f: 'ふ',\n  };\n\n  // things like うぃ, くぃ, etc.\n  for (const [consonant, aiueoKan] of Object.entries(aiueoConstructions)) {\n    for (const [vow, kan] of Object.entries(smallaiueo)) {\n      const subtree = subtreeOf(consonant + vow);\n      subtree[''] = aiueoKan + kan;\n    }\n  }\n\n  // different ways to write ん\n  for (const nvar of ['n', \"n'\", 'xn']) {\n    subtreeOf(nvar)[''] = 'ん';\n  }\n\n  // typing one should be the same as having typed the other instead\n  const alternativeMappings = {\n    sh: 'sy', // sha -> sya\n    ch: 'ty', // cho -> tyo\n    cy: 'ty', // cyo -> tyo\n    chy: 'ty', // chyu -> tyu\n    shy: 'sy', // shya -> sya\n    j: 'zy', // ja -> zya\n    jy: 'zy', // jye -> zye\n\n    // exceptions to above rules\n    shi: 'si',\n    chi: 'ti',\n    tsu: 'tu',\n    ji: 'zi',\n    fu: 'hu',\n  };\n\n  // c is equivalent to k, but not for chi, cha, etc. that's why we have to make a copy of k\n  kanaTree.c = JSON.parse(JSON.stringify(kanaTree.k));\n\n  for (const [string, alternative] of Object.entries(alternativeMappings)) {\n    const allExceptLast = string.slice(0, string.length - 1);\n    const last = string.charAt(string.length - 1);\n    const parentTree = subtreeOf(allExceptLast);\n    // copy to avoid recursive containment\n    parentTree[last] = JSON.parse(JSON.stringify(subtreeOf(alternative)));\n  }\n\n  // xtu -> っ\n  const smallLetters = Object.assign(\n    {\n      tu: 'っ',\n      wa: 'ゎ',\n      ka: 'ヵ',\n      ke: 'ヶ',\n    },\n    smallaiueo,\n    smallY\n  );\n\n  function getAlternatives(string) {\n    const result = [];\n    for (const [alt, rom] of Object.entries(alternativeMappings).concat([['c', 'k']])) {\n      if (string.startsWith(rom)) {\n        result.push(string.replace(rom, alt));\n      }\n    }\n    return result;\n  }\n\n  for (const [kunreiRom, kan] of Object.entries(smallLetters)) {\n    {\n      const xRom = `x${kunreiRom}`;\n      const xSubtree = subtreeOf(xRom);\n      xSubtree[''] = kan;\n\n      // ltu -> xtu -> っ\n      const allExceptLast = kunreiRom.slice(0, kunreiRom.length - 1);\n      const last = kunreiRom.charAt(kunreiRom.length - 1);\n      const parentTree = subtreeOf(`l${allExceptLast}`);\n      parentTree[last] = xSubtree;\n    }\n\n    // ltsu -> ltu -> っ\n    for (const altRom of getAlternatives(kunreiRom)) {\n      const allExceptLast = altRom.slice(0, altRom.length - 1);\n      const last = altRom.charAt(altRom.length - 1);\n      for (const prefix of ['l', 'x']) {\n        const parentTree = subtreeOf(prefix + allExceptLast);\n        parentTree[last] = subtreeOf(prefix + kunreiRom);\n      }\n    }\n  }\n\n  // don't follow any notable patterns\n  const individualCases = {\n    yi: 'い',\n    wu: 'う',\n    ye: 'いぇ',\n    wi: 'うぃ',\n    we: 'うぇ',\n    kwa: 'くぁ',\n    whu: 'う',\n    // because it's not thya for てゃ but tha\n    // and tha is not てぁ, but てゃ\n    tha: 'てゃ',\n    thu: 'てゅ',\n    tho: 'てょ',\n    dha: 'でゃ',\n    dhu: 'でゅ',\n    dho: 'でょ',\n  };\n\n  for (const [string, kana] of Object.entries(individualCases)) {\n    subtreeOf(string)[''] = kana;\n  }\n\n  // add kka, tta, etc.\n  function addTsu(tree) {\n    const result = {};\n    for (const [key, value] of Object.entries(tree)) {\n      if (!key) {\n        // we have reached the bottom of this branch\n        result[key] = `っ${value}`;\n      } else {\n        // more subtrees\n        result[key] = addTsu(value);\n      }\n    }\n    return result;\n  }\n  // have to explicitly name c here, because we made it a copy of k, not a reference\n  for (const consonant of Object.keys(consonants).concat('c', 'y', 'w', 'j')) {\n    const subtree = kanaTree[consonant];\n    subtree[consonant] = addTsu(subtree);\n  }\n  // nn should not be っん\n  delete kanaTree.n.n;\n  // solidify the results, so that there there is referential transparency within the tree\n  return Object.freeze(JSON.parse(JSON.stringify(kanaTree)));\n}\n\nexport function getRomajiToKanaTree(config) {\n  if (romajiToKanaMap === null) {\n    romajiToKanaMap = createRomajiToKanaMap();\n  }\n  return romajiToKanaMap;\n}\n\nexport const USE_OBSOLETE_KANA_MAP = createCustomMapping({ wi: 'ゐ', we: 'ゑ' });\n\nexport function IME_MODE_MAP(map) {\n  // in IME mode, we do not want to convert single ns\n  const mapCopy = JSON.parse(JSON.stringify(map));\n  mapCopy.n.n = { '': 'ん' };\n  mapCopy.n[' '] = { '': 'ん' };\n  return mapCopy;\n}\n","import isEmpty from './isEmpty';\nimport isCharInRange from './isCharInRange';\nimport { LATIN_UPPERCASE_START, LATIN_UPPERCASE_END } from '../constants';\n\n/**\n * Tests if char is in English unicode uppercase range\n * @param  {String} char\n * @return {Boolean}\n */\nfunction isCharUpperCase(char = '') {\n  if (isEmpty(char)) return false;\n  return isCharInRange(char, LATIN_UPPERCASE_START, LATIN_UPPERCASE_END);\n}\n\nexport default isCharUpperCase;\n","import isEmpty from './isEmpty';\nimport { PROLONGED_SOUND_MARK } from '../constants';\n\n/**\n * Returns true if char is 'ー'\n * @param  {String} char to test\n * @return {Boolean}\n */\nfunction isCharLongDash(char = '') {\n  if (isEmpty(char)) return false;\n  return char.charCodeAt(0) === PROLONGED_SOUND_MARK;\n}\n\nexport default isCharLongDash;\n","import isEmpty from './isEmpty';\nimport { KANA_SLASH_DOT } from '../constants';\n\n/**\n * Tests if char is '・'\n * @param  {String} char\n * @return {Boolean} true if '・'\n */\nfunction isCharSlashDot(char = '') {\n  if (isEmpty(char)) return false;\n  return char.charCodeAt(0) === KANA_SLASH_DOT;\n}\n\nexport default isCharSlashDot;\n","import isEmpty from './isEmpty';\nimport isCharLongDash from './isCharLongDash';\nimport isCharInRange from './isCharInRange';\nimport {\n  HIRAGANA_START,\n  HIRAGANA_END,\n} from '../constants';\n\n/**\n * Tests a character. Returns true if the character is [Hiragana](https://en.wikipedia.org/wiki/Hiragana).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharHiragana(char = '') {\n  if (isEmpty(char)) return false;\n  if (isCharLongDash(char)) return true;\n  return isCharInRange(char, HIRAGANA_START, HIRAGANA_END);\n}\n\nexport default isCharHiragana;\n","import {\n  KATAKANA_START,\n  HIRAGANA_START,\n} from '../constants';\n\nimport isCharLongDash from './isCharLongDash';\nimport isCharSlashDot from './isCharSlashDot';\nimport isCharHiragana from './isCharHiragana';\n\n/**\n * Convert [Hiragana](https://en.wikipedia.org/wiki/Hiragana) to [Katakana](https://en.wikipedia.org/wiki/Katakana)\n * Passes through any non-hiragana chars\n * @param  {String} [input=''] text input\n * @return {String} converted text\n * @example\n * hiraganaToKatakana('ひらがな')\n * // => \"ヒラガナ\"\n * hiraganaToKatakana('ひらがな is a type of kana')\n * // => \"ヒラガナ is a type of kana\"\n * @ignore\n */\nfunction hiraganaToKatakana(input = '') {\n  const kata = [];\n  input.split('').forEach((char) => {\n    // Short circuit to avoid incorrect codeshift for 'ー' and '・'\n    if (isCharLongDash(char) || isCharSlashDot(char)) {\n      kata.push(char);\n    } else if (isCharHiragana(char)) {\n      // Shift charcode.\n      const code = char.charCodeAt(0) + (KATAKANA_START - HIRAGANA_START);\n      const kataChar = String.fromCharCode(code);\n      kata.push(kataChar);\n    } else {\n      // Pass non-hiragana chars through\n      kata.push(char);\n    }\n  });\n  return kata.join('');\n}\n\nexport default hiraganaToKatakana;\n","import mergeWithDefaultOptions from './utils/mergeWithDefaultOptions';\nimport { getRomajiToKanaTree, IME_MODE_MAP, USE_OBSOLETE_KANA_MAP } from './utils/romajiToKanaMap';\nimport { applyMapping, mergeCustomMapping } from './utils/kanaMapping';\nimport isEmpty from './utils/isEmpty';\nimport isCharUpperCase from './utils/isCharUpperCase';\nimport hiraganaToKatakana from './utils/hiraganaToKatakana';\n\n/**\n * Convert [Romaji](https://en.wikipedia.org/wiki/Romaji) to [Kana](https://en.wikipedia.org/wiki/Kana), lowercase text will result in [Hiragana](https://en.wikipedia.org/wiki/Hiragana) and uppercase text will result in [Katakana](https://en.wikipedia.org/wiki/Katakana).\n * @param  {String} [input=''] text\n * @param  {DefaultOptions} [options=defaultOptions]\n * @return {String} converted text\n * @example\n * toKana('onaji BUTTSUUJI')\n * // => 'おなじ ブッツウジ'\n * toKana('ONAJI buttsuuji')\n * // => 'オナジ ぶっつうじ'\n * toKana('座禅‘zazen’スタイル')\n * // => '座禅「ざぜん」スタイル'\n * toKana('batsuge-mu')\n * // => 'ばつげーむ'\n * toKana('!?.:/,~-‘’“”[](){}') // Punctuation conversion\n * // => '！？。：・、〜ー「」『』［］（）｛｝'\n * toKana('we', { useObsoleteKana: true })\n * // => 'ゑ'\n * toKana('WanaKana', { customKanaMapping: { na: 'に', ka: 'Bana' } });\n * // => 'ワにBanaに'\n */\nexport function toKana(input = '', options = {}) {\n  if (isEmpty(input)) {\n    return input;\n  }\n  // throw away the substring index information and just concatenate all the kana\n  return splitIntoConvertedKana(input, options)\n    .map((kanaToken) => {\n      const [start, , kana] = kanaToken;\n      if (kana === null) {\n        // haven't converted the end of the string, since we are in IME mode\n        return input.slice(start);\n      }\n      // make katakana, if the first letter of the syllable is upper case\n      return isCharUpperCase(input.charAt(start)) ? hiraganaToKatakana(kana) : kana;\n    })\n    .join('');\n}\n\nexport function createRomajiToKanaMap(config = {}) {\n  let map = getRomajiToKanaTree(config);\n  map = config.IMEMode ? IME_MODE_MAP(map) : map;\n  map = config.useObsoleteKana ? USE_OBSOLETE_KANA_MAP(map) : map;\n  return mergeCustomMapping(map, config.customKanaMapping);\n}\n\n/**\n *\n * @param {String} [input=''] input text\n * @param {Object} [options={}] toKana options\n * @returns {Array[]} [[start, end, token]]\n * @ignore\n * @example\n * splitIntoConvertedKana('buttsuuji')\n * // => [[0, 2, 'ぶ'], [2, 6, 'っつ'], [6, 7, 'う'], [7, 9, 'じ']]\n */\nexport function splitIntoConvertedKana(input = '', options = {}) {\n  const config = mergeWithDefaultOptions(options);\n  const map = createRomajiToKanaMap(config);\n  return applyMapping(input.toLowerCase(), map, !config.IMEMode);\n}\n\nexport default toKana;\n","import { TO_KANA_METHODS } from '../constants';\nimport isJapanese from '../isJapanese';\nimport toKana, { createRomajiToKanaMap } from '../toKana';\nimport mergeWithDefaultOptions from './mergeWithDefaultOptions';\n\nlet LISTENERS = [];\n\n/**\n * Automagically replaces input values with converted text to kana\n * @param  {defaultOptions} [options] user config overrides, default conversion is toKana()\n * @return {Function} event handler with bound options\n * @ignore\n */\nexport function makeOnInput(options, el) {\n  const mergedConfig = Object.assign({}, mergeWithDefaultOptions(options), {\n    IMEMode: options.IMEMode || true,\n  });\n\n  return function onInput({ target }) {\n    const { dataset, value, selectionEnd } = target;\n    if (dataset.isComposing) {\n      console.log(`isComposing: early exit for value: ${value}`);\n      return;\n    }\n    const [head, textToConvert, tail] = splitInput(value, selectionEnd, mergedConfig);\n    const convertedText = toKana(textToConvert, mergedConfig);\n    if (textToConvert !== convertedText) {\n      target.value = head + convertedText + tail;\n      const newCursor = head.length + convertedText.length;\n      target.setSelectionRange(newCursor, newCursor);\n    }\n  };\n}\n\nexport function onComposition({ target, type }) {\n  const isChrome = window && !!window.chrome && !!window.chrome.webstore;\n\n  if (type === 'compositionend') {\n    target.dataset.isComposing = false;\n\n    // Chrome fires 'compositionEnd' event after 'input' event.\n    // https://chromium.googlesource.com/chromium/src/+/afce9d93e76f2ff81baaa088a4ea25f67d1a76b3%5E%21/\n    if (isChrome) {\n      const inputEvent = new Event('input');\n      target.dispatchEvent(inputEvent);\n    }\n  } else {\n    // in composition\n    target.dataset.isComposing = true;\n  }\n}\n\nexport function trackListeners(id, inputHandler, compositionHandler) {\n  LISTENERS = LISTENERS.concat({\n    id,\n    inputHandler,\n    compositionHandler,\n  });\n}\n\nexport function untrackListeners({ id: targetId }) {\n  LISTENERS = LISTENERS.filter(({ id }) => id !== targetId);\n}\n\nexport function findListeners(el) {\n  return el && LISTENERS.find(({ id }) => id === el.getAttribute('data-wanakana-id'));\n}\n\n// so we can handle non-terminal inserted input conversion:\n// | -> わ| -> わび| -> わ|び -> わs|び -> わsh|び -> わshi|び -> わし|び\n// or multiple ambiguous positioning (IE select which \"s\" to work from)\n// こsこs|こsこ -> こsこso|こsこ -> こsこそ|こsこ\nexport function splitInput(text = '', startIndex = 0, config = {}) {\n  let head;\n  let toConvert;\n  let tail;\n  let triggers = Object.keys(createRomajiToKanaMap(config));\n  triggers = [...triggers, ...triggers.map((char) => char.toUpperCase())];\n\n  if (startIndex === 0 && triggers.includes(text[0])) {\n    [head, toConvert, tail] = workFromStart(text, triggers);\n    // NOTE: maybe we can just *always* work backwards?\n  } else if (startIndex > 0) {\n    [head, toConvert, tail] = workBackwards(text, startIndex);\n  } else {\n    [head, toConvert] = takeWhileAndSlice(text, (char) => !triggers.includes(char));\n    [toConvert, tail] = takeWhileAndSlice(toConvert, (char) => !isJapanese(char));\n  }\n\n  return [head, setKanaType(toConvert, config), tail];\n}\n\nfunction workFromStart(text, catalystChars) {\n  return [\n    '',\n    ...takeWhileAndSlice(\n      text,\n      (char) => catalystChars.includes(char) || !isJapanese(char, /[0-9]/)\n    ),\n  ];\n}\n\nfunction workBackwards(text = '', startIndex = 0) {\n  const [toConvert, head] = takeWhileAndSlice(\n    [...text.slice(0, startIndex)].reverse(),\n    (char) => !isJapanese(char)\n  );\n  return [\n    head.reverse().join(''),\n    toConvert\n      .split('')\n      .reverse()\n      .join(''),\n    text.slice(startIndex),\n  ];\n}\n\nfunction takeWhileAndSlice(source = {}, predicate = (x) => !!x) {\n  const result = [];\n  const { length } = source;\n  let i = 0;\n  while (i < length && predicate(source[i], i)) {\n    result.push(source[i]);\n    i += 1;\n  }\n  return [result.join(''), source.slice(i)];\n}\n\n// allow us to to continue use `toKana` to handle IME input with forced conversion type\nfunction setKanaType(input = '', { IMEMode } = {}) {\n  switch (true) {\n    case IMEMode === TO_KANA_METHODS.HIRAGANA:\n      return input.toLowerCase();\n    case IMEMode === TO_KANA_METHODS.KATAKANA:\n      return input.toUpperCase();\n    default:\n      return input;\n  }\n}\n","import { makeOnInput, onComposition, trackListeners } from './utils/dom';\nimport { addDebugListeners } from './utils/logInputEvents';\n\nconst ELEMENTS = ['TEXTAREA', 'INPUT'];\n\nlet idCounter = 0;\nconst newId = () => {\n  idCounter += 1;\n  return `${Date.now()}${idCounter}`;\n};\n\n/**\n * Binds eventListener for 'input' events to an input field to automagically replace values with kana\n * Can pass { IMEMode: 'toHiragana' } or `'toKatakana'` as second param to enforce kana conversion type\n * @param  {HTMLElement} input textarea, input[type=\"text\"] etc\n * @param  {DefaultOptions} [options=defaultOptions] defaults to { IMEMode: true } using `toKana`\n */\nfunction bind(input = {}, options = {}, debug = false) {\n  if (!ELEMENTS.includes(input.nodeName)) {\n    throw new Error(\n      `Element provided to Wanakana bind() was not a valid input or textarea element.\\n Received: (${JSON.stringify(\n        input\n      )})`\n    );\n  }\n  const onInput = makeOnInput(options, input);\n  const id = newId();\n  input.setAttribute('data-wanakana-id', id);\n  //  input.autocapitalize = 'none'; // eslint-disable-line no-param-reassign\n  input.addEventListener('input', onInput);\n  input.addEventListener('compositionstart', onComposition);\n  input.addEventListener('compositionchange', onComposition);\n  input.addEventListener('compositionend', onComposition);\n  trackListeners(id, onInput, onComposition);\n  if (debug === true) {\n    addDebugListeners(input);\n  }\n}\n\nexport default bind;\n","import { findListeners, untrackListeners } from './utils/dom';\nimport { removeDebugListeners } from './utils/logInputEvents';\n\n/**\n * Unbinds eventListener from input field\n * @param  {HTMLElement} input <textarea>, <input>\n */\nexport function unbind(input, debug = false) {\n  const listeners = findListeners(input);\n  if (listeners == null) {\n    throw new Error(\n      `Element provided to Wanakana unbind() had no listener registered.\\n Received: ${JSON.stringify(\n        input\n      )}`\n    );\n  }\n  const { inputHandler, compositionHandler } = listeners;\n  input.removeAttribute('data-wanakana-id');\n  input.removeAttribute('data-is-composing');\n  input.removeEventListener('input', inputHandler);\n  input.removeEventListener('compositionstart', compositionHandler);\n  input.removeEventListener('compositionupdate', compositionHandler);\n  input.removeEventListener('compositionend', compositionHandler);\n  untrackListeners(listeners);\n  if (debug === true) {\n    removeDebugListeners(input);\n  }\n}\n\nexport default unbind;\n","import isEmpty from './isEmpty';\nimport isCharInRange from './isCharInRange';\nimport { ROMAJI_RANGES } from '../constants';\n\n/**\n * Tests a character. Returns true if the character is [Romaji](https://en.wikipedia.org/wiki/Romaji) (allowing [Hepburn romanisation](https://en.wikipedia.org/wiki/Hepburn_romanization))\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharRomaji(char = '') {\n  if (isEmpty(char)) return false;\n  return ROMAJI_RANGES.some(([start, end]) => isCharInRange(char, start, end));\n}\n\nexport default isCharRomaji;\n","import typeOf from './utils/typeOf';\nimport isEmpty from './utils/isEmpty';\nimport isCharRomaji from './utils/isCharRomaji';\n\n/**\n * Test if `input` is [Romaji](https://en.wikipedia.org/wiki/Romaji) (allowing [Hepburn romanisation](https://en.wikipedia.org/wiki/Hepburn_romanization))\n * @param  {String} [input=''] text\n * @param  {Regexp} [allowed] additional test allowed to pass for each char\n * @return {Boolean} true if [Romaji](https://en.wikipedia.org/wiki/Romaji)\n * @example\n * isRomaji('Tōkyō and Ōsaka')\n * // => true\n * isRomaji('12a*b&c-d')\n * // => true\n * isRomaji('あアA')\n * // => false\n * isRomaji('お願い')\n * // => false\n * isRomaji('a！b&cーd') // Zenkaku punctuation fails\n * // => false\n * isRomaji('a！b&cーd', /[！ー]/)\n * // => true\n */\nfunction isRomaji(input = '', allowed) {\n  const augmented = typeOf(allowed) === 'regexp';\n  return isEmpty(input)\n    ? false\n    : [...input].every((char) => {\n      const isRoma = isCharRomaji(char);\n      return !augmented ? isRoma : isRoma || allowed.test(char);\n    });\n}\n\nexport default isRomaji;\n","import {\n  KATAKANA_START,\n  KATAKANA_END,\n} from '../constants';\n\nimport isCharInRange from './isCharInRange';\n\n/**\n * Tests a character. Returns true if the character is [Katakana](https://en.wikipedia.org/wiki/Katakana).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharKatakana(char = '') {\n  return isCharInRange(char, KATAKANA_START, KATAKANA_END);\n}\n\nexport default isCharKatakana;\n","import isEmpty from './isEmpty';\nimport isCharHiragana from './isCharHiragana';\nimport isCharKatakana from './isCharKatakana';\n\n/**\n * Tests a character. Returns true if the character is [Hiragana](https://en.wikipedia.org/wiki/Hiragana) or [Katakana](https://en.wikipedia.org/wiki/Katakana).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharKana(char = '') {\n  if (isEmpty(char)) return false;\n  return isCharHiragana(char) || isCharKatakana(char);\n}\n\nexport default isCharKana;\n","import isEmpty from './utils/isEmpty';\nimport isCharKana from './utils/isCharKana';\n\n/**\n * Test if `input` is [Kana](https://en.wikipedia.org/wiki/Kana) ([Katakana](https://en.wikipedia.org/wiki/Katakana) and/or [Hiragana](https://en.wikipedia.org/wiki/Hiragana))\n * @param  {String} [input=''] text\n * @return {Boolean} true if all [Kana](https://en.wikipedia.org/wiki/Kana)\n * @example\n * isKana('あ')\n * // => true\n * isKana('ア')\n * // => true\n * isKana('あーア')\n * // => true\n * isKana('A')\n * // => false\n * isKana('あAア')\n * // => false\n */\nfunction isKana(input = '') {\n  if (isEmpty(input)) return false;\n  return [...input].every(isCharKana);\n}\n\nexport default isKana;\n","import isEmpty from './utils/isEmpty';\nimport isCharHiragana from './utils/isCharHiragana';\n\n/**\n * Test if `input` is [Hiragana](https://en.wikipedia.org/wiki/Hiragana)\n * @param  {String} [input=''] text\n * @return {Boolean} true if all [Hiragana](https://en.wikipedia.org/wiki/Hiragana)\n * @example\n * isHiragana('げーむ')\n * // => true\n * isHiragana('A')\n * // => false\n * isHiragana('あア')\n * // => false\n */\nfunction isHiragana(input = '') {\n  if (isEmpty(input)) return false;\n  return [...input].every(isCharHiragana);\n}\n\nexport default isHiragana;\n","import isEmpty from './utils/isEmpty';\nimport isCharKatakana from './utils/isCharKatakana';\n\n/**\n * Test if `input` is [Katakana](https://en.wikipedia.org/wiki/Katakana)\n * @param  {String} [input=''] text\n * @return {Boolean} true if all [Katakana](https://en.wikipedia.org/wiki/Katakana)\n * @example\n * isKatakana('ゲーム')\n * // => true\n * isKatakana('あ')\n * // => false\n * isKatakana('A')\n * // => false\n * isKatakana('あア')\n * // => false\n */\nfunction isKatakana(input = '') {\n  if (isEmpty(input)) return false;\n  return [...input].every(isCharKatakana);\n}\n\nexport default isKatakana;\n","import {\n  KANJI_START,\n  KANJI_END,\n} from '../constants';\n\nimport isCharInRange from './isCharInRange';\n/**\n * Tests a character. Returns true if the character is a CJK ideograph (kanji).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharKanji(char = '') {\n  return isCharInRange(char, KANJI_START, KANJI_END);\n}\n\nexport default isCharKanji;\n","import isEmpty from './utils/isEmpty';\nimport isCharKanji from './utils/isCharKanji';\n\n/**\n * Tests if `input` is [Kanji](https://en.wikipedia.org/wiki/Kanji) ([Japanese CJK ideographs](https://en.wikipedia.org/wiki/CJK_Unified_Ideographs))\n * @param  {String} [input=''] text\n * @return {Boolean} true if all [Kanji](https://en.wikipedia.org/wiki/Kanji)\n * @example\n * isKanji('刀')\n * // => true\n * isKanji('切腹')\n * // => true\n * isKanji('勢い')\n * // => false\n * isKanji('あAア')\n * // => false\n * isKanji('🐸')\n * // => false\n */\nfunction isKanji(input = '') {\n  if (isEmpty(input)) return false;\n  return [...input].every(isCharKanji);\n}\n\nexport default isKanji;\n","import isKanji from './isKanji';\nimport isHiragana from './isHiragana';\nimport isKatakana from './isKatakana';\nimport isRomaji from './isRomaji';\n\n/**\n * Test if `input` contains a mix of [Romaji](https://en.wikipedia.org/wiki/Romaji) *and* [Kana](https://en.wikipedia.org/wiki/Kana), defaults to pass through [Kanji](https://en.wikipedia.org/wiki/Kanji)\n * @param  {String} input text\n * @param  {Object} [options={ passKanji: true }] optional config to pass through kanji\n * @return {Boolean} true if mixed\n * @example\n * isMixed('Abあア'))\n * // => true\n * isMixed('お腹A'))\n * // => true\n * isMixed('お腹A', { passKanji: false }))\n * // => false\n * isMixed('ab'))\n * // => false\n * isMixed('あア'))\n * // => false\n */\nfunction isMixed(input = '', options = { passKanji: true }) {\n  const chars = [...input];\n  let hasKanji = false;\n  if (!options.passKanji) {\n    hasKanji = chars.some(isKanji);\n  }\n  return (chars.some(isHiragana) || chars.some(isKatakana)) && chars.some(isRomaji) && !hasKanji;\n}\n\nexport default isMixed;\n","import { KATAKANA_START, HIRAGANA_START } from '../constants';\nimport toRomaji from '../toRomaji';\n\nimport isCharLongDash from './isCharLongDash';\nimport isCharSlashDot from './isCharSlashDot';\nimport isCharKatakana from './isCharKatakana';\nconst isCharInitialLongDash = (char, index) => isCharLongDash(char) && index < 1;\nconst isCharInnerLongDash = (char, index) => isCharLongDash(char) && index > 0;\nconst isKanaAsSymbol = (char) => ['ヶ', 'ヵ'].includes(char);\nconst LONG_VOWELS = {\n  a: 'あ',\n  i: 'い',\n  u: 'う',\n  e: 'え',\n  o: 'う',\n};\n\n/**\n * Convert [Katakana](https://en.wikipedia.org/wiki/Katakana) to [Hiragana](https://en.wikipedia.org/wiki/Hiragana)\n * Passes through any non-katakana chars\n * @param  {String} [input=''] text input\n * @return {String} converted text\n * @example\n * katakanaToHiragana('カタカナ')\n * // => \"かたかな\"\n * katakanaToHiragana('カタカナ is a type of kana')\n * // => \"かたかな is a type of kana\"\n * @ignore\n */\nfunction katakanaToHiragana(input = '') {\n  const hira = [];\n  let previousKana = '';\n  const iterable = input.split('');\n  for (let index = 0; index < iterable.length; index += 1) {\n    const char = iterable[index];\n    // Short circuit to avoid incorrect codeshift for 'ー' and '・'\n    if (isCharSlashDot(char) || isCharInitialLongDash(char, index) || isKanaAsSymbol(char)) {\n      hira.push(char);\n      // Transform long vowels: 'オー' to 'おう'\n    } else if (previousKana && isCharInnerLongDash(char, index)) {\n      // Transform previousKana back to romaji, and slice off the vowel\n      const romaji = toRomaji(previousKana).slice(-1);\n      hira.push(LONG_VOWELS[romaji]);\n    } else if (!isCharLongDash(char) && isCharKatakana(char)) {\n      // Shift charcode.\n      const code = char.charCodeAt(0) + (HIRAGANA_START - KATAKANA_START);\n      const hiraChar = String.fromCharCode(code);\n      hira.push(hiraChar);\n      previousKana = hiraChar;\n    } else {\n      // Pass non katakana chars through\n      hira.push(char);\n      previousKana = '';\n    }\n  }\n  return hira.join('');\n}\n\nexport default katakanaToHiragana;\n","import toKana from '../toKana';\n\n/**\n * Convert [Romaji](https://en.wikipedia.org/wiki/Romaji) to [Hiragana](https://en.wikipedia.org/wiki/Hiragana)\n * @param  {String} [input=''] text\n * @param  {Object} options used internally to pass along default options\n * @return {String} converted text\n * @example\n * romajiToHiragana('hiragana')\n * // => \"ひらがな\"\n * @ignore\n */\nfunction romajiToHiragana(input = '', options = {}) {\n  const text = input.toLowerCase(); // ensure hiragana\n  return toKana(text, options);\n}\n\nexport default romajiToHiragana;\n","import isEmpty from './isEmpty';\nimport { EN_PUNCTUATION_RANGES } from '../constants';\nimport isCharInRange from './isCharInRange';\n\n/**\n * Tests a character. Returns true if the character is considered English punctuation.\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharEnglishPunctuation(char = '') {\n  if (isEmpty(char)) return false;\n  return EN_PUNCTUATION_RANGES.some(([start, end]) => isCharInRange(char, start, end));\n}\n\nexport default isCharEnglishPunctuation;\n","import mergeWithDefaultOptions from './utils/mergeWithDefaultOptions';\nimport katakanaToHiragana from './utils/katakanaToHiragana';\nimport romajiToHiragana from './utils/romajiToHiragana';\nimport isCharEnglishPunctuation from './utils/isCharEnglishPunctuation';\nimport isRomaji from './isRomaji';\nimport isMixed from './isMixed';\nimport isKatakana from './isKatakana';\n\n/**\n * Convert input to [Hiragana](https://en.wikipedia.org/wiki/Hiragana)\n * @param  {String} [input=''] text\n * @param  {DefaultOptions} [options=defaultOptions]\n * @return {String} converted text\n * @example\n * toHiragana('toukyou, オオサカ')\n * // => 'とうきょう、　おおさか'\n * toHiragana('only カナ', { passRomaji: true })\n * // => 'only かな'\n * toHiragana('wi')\n * // => 'うぃ'\n * toHiragana('wi', { useObsoleteKana: true })\n * // => 'ゐ'\n */\nfunction toHiragana(input = '', options = {}) {\n  const config = mergeWithDefaultOptions(options);\n  if (config.passRomaji) {\n    return katakanaToHiragana(input);\n  }\n\n  if (isRomaji(input) || isCharEnglishPunctuation(input)) {\n    return romajiToHiragana(input, config);\n  }\n\n  if (isMixed(input, { passKanji: true })) {\n    const romaji = katakanaToHiragana(input);\n    return romajiToHiragana(romaji, config);\n  }\n\n  return katakanaToHiragana(input);\n}\n\nexport default toHiragana;\n","import { transform, getSubTreeOf } from './kanaMapping';\nimport { ROMANIZATIONS } from '../constants';\n\nlet kanaToHepburnMap = null;\n\nfunction createKanaToHepburnMap() {\n  const romajiTree = transform({\n    あ: 'a',\n    い: 'i',\n    う: 'u',\n    え: 'e',\n    お: 'o',\n    か: 'ka',\n    き: 'ki',\n    く: 'ku',\n    け: 'ke',\n    こ: 'ko',\n    さ: 'sa',\n    し: 'shi',\n    す: 'su',\n    せ: 'se',\n    そ: 'so',\n    た: 'ta',\n    ち: 'chi',\n    つ: 'tsu',\n    て: 'te',\n    と: 'to',\n    な: 'na',\n    に: 'ni',\n    ぬ: 'nu',\n    ね: 'ne',\n    の: 'no',\n    は: 'ha',\n    ひ: 'hi',\n    ふ: 'fu',\n    へ: 'he',\n    ほ: 'ho',\n    ま: 'ma',\n    み: 'mi',\n    む: 'mu',\n    め: 'me',\n    も: 'mo',\n    や: 'ya',\n    ゆ: 'yu',\n    よ: 'yo',\n    ら: 'ra',\n    り: 'ri',\n    る: 'ru',\n    れ: 're',\n    ろ: 'ro',\n    わ: 'wa',\n    ゐ: 'wi',\n    ゑ: 'we',\n    を: 'wo',\n    が: 'ga',\n    ぎ: 'gi',\n    ぐ: 'gu',\n    げ: 'ge',\n    ご: 'go',\n    ざ: 'za',\n    じ: 'ji',\n    ず: 'zu',\n    ぜ: 'ze',\n    ぞ: 'zo',\n    だ: 'da',\n    ぢ: 'ji',\n    づ: 'zu',\n    で: 'de',\n    ど: 'do',\n    ば: 'ba',\n    び: 'bi',\n    ぶ: 'bu',\n    べ: 'be',\n    ぼ: 'bo',\n    ぱ: 'pa',\n    ぴ: 'pi',\n    ぷ: 'pu',\n    ぺ: 'pe',\n    ぽ: 'po',\n    ゔぁ: 'va',\n    ゔぃ: 'vi',\n    ゔ: 'vu',\n    ゔぇ: 've',\n    ゔぉ: 'vo',\n    ん: 'n',\n  });\n\n  const subtreeOf = (string) => getSubTreeOf(romajiTree, string);\n  const setTrans = (string, transliteration) => {\n    subtreeOf(string)[''] = transliteration;\n  };\n\n  const specialSymbols = {\n    '。': '.',\n    '、': ',',\n    '：': ':',\n    '・': '/',\n    '！': '!',\n    '？': '?',\n    '〜': '~',\n    'ー': '-',\n    '「': '‘',\n    '」': '’',\n    '『': '“',\n    '』': '”',\n    '［': '[',\n    '］': ']',\n    '（': '(',\n    '）': ')',\n    '｛': '{',\n    '｝': '}',\n    '　': ' ',\n  };\n\n  for (const [jsymbol, symbol] of Object.entries(specialSymbols)) {\n    subtreeOf(jsymbol)[''] = symbol;\n  }\n\n  /* eslint-disable object-curly-newline */\n  const smallY = { ゃ: 'ya', ゅ: 'yu', ょ: 'yo' };\n  const smallYExtra = { ぃ: 'yi', ぇ: 'ye' };\n  const smallaiueo = { ぁ: 'a', ぃ: 'i', ぅ: 'u', ぇ: 'e', ぉ: 'o' };\n\n  for (const [rom, kan] of Object.entries(smallY).concat(Object.entries(smallaiueo))) {\n    setTrans(rom, kan);\n  }\n\n  const yoonKana = ['き', 'に', 'ひ', 'み', 'り', 'ぎ', 'び', 'ぴ', 'ゔ', 'く', 'ふ'];\n  // きゃ -> kya\n  for (const kana of yoonKana) {\n    const fistRomajiLetter = subtreeOf(kana)[''][0];\n    for (const [yKan, yRom] of Object.entries(smallY)) {\n      setTrans(kana + yKan, fistRomajiLetter + yRom);\n    }\n    // きぃ -> kyi\n    for (const [yKan, yRom] of Object.entries(smallYExtra)) {\n      setTrans(kana + yKan, fistRomajiLetter + yRom);\n    }\n  }\n  const yoonExceptions = { し: 'sh', ち: 'ch', じ: 'j', ぢ: 'j' };\n  for (const [kana, rom] of Object.entries(yoonExceptions)) {\n    // じゃ -> ja\n    for (const [yKan, yRom] of Object.entries(smallY)) {\n      setTrans(kana + yKan, rom + yRom[1]);\n    }\n    // じぃ -> jyi, じぇ -> je\n    setTrans(`${kana}ぃ`, `${rom}yi`);\n    setTrans(`${kana}ぇ`, `${rom}e`);\n  }\n\n  // going with the intuitive (yet incorrect) solution where っや -> yya and っぃ -> ii\n  // in other words, just assume the sokuon could have been applied to anything\n\n  const sokuonWhitelist = {\n    b: 'b',\n    c: 't',\n    d: 'd',\n    f: 'f',\n    g: 'g',\n    h: 'h',\n    j: 'j',\n    k: 'k',\n    m: 'm',\n    p: 'p',\n    q: 'q',\n    r: 'r',\n    s: 's',\n    t: 't',\n    v: 'v',\n    w: 'w',\n    x: 'x',\n    z: 'z',\n  };\n\n  function resolveTsu(tree) {\n    const result = {};\n    for (const [key, value] of Object.entries(tree)) {\n      if (!key) {\n        // we have reached the bottom of this branch\n        const consonant = value.charAt(0);\n        result[key] = consonant in sokuonWhitelist ? sokuonWhitelist[consonant] + value : value;\n      } else {\n        // more subtrees\n        result[key] = resolveTsu(value);\n      }\n    }\n    return result;\n  }\n\n  romajiTree['っ'] = resolveTsu(romajiTree);\n\n  const smallLetters = {\n    っ: '',\n    ゃ: 'ya',\n    ゅ: 'yu',\n    ょ: 'yo',\n    ぁ: 'a',\n    ぃ: 'i',\n    ぅ: 'u',\n    ぇ: 'e',\n    ぉ: 'o',\n  };\n\n  for (const [kan, rom] of Object.entries(smallLetters)) {\n    setTrans(kan, rom);\n  }\n\n  // んい -> n'i\n  const ambig = ['あ', 'い', 'う', 'え', 'お', 'や', 'ゆ', 'よ'];\n  for (const kan of ambig) {\n    setTrans(`ん${kan}`, `n'${subtreeOf(kan)['']}`);\n  }\n  // NOTE: could be re-enabled with an option?\n  // // んば -> mbo\n  // const labial = [\n  //   'ば', 'び', 'ぶ', 'べ', 'ぼ',\n  //   'ぱ', 'ぴ', 'ぷ', 'ぺ', 'ぽ',\n  //   'ま', 'み', 'む', 'め', 'も',\n  // ];\n  // for (const kan of labial) {\n  //   setTrans(`ん${kan}`, `m${subtreeOf(kan)['']}`);\n  // }\n\n  return Object.freeze(JSON.parse(JSON.stringify(romajiTree)));\n}\n\nfunction getKanaToHepburnTree() {\n  if (kanaToHepburnMap === null) {\n    kanaToHepburnMap = createKanaToHepburnMap();\n  }\n  return kanaToHepburnMap;\n}\n\nexport function getKanaToRomajiTree(fullOptions) {\n  switch (fullOptions.romanization) {\n    case ROMANIZATIONS.HEPBURN:\n      return getKanaToHepburnTree(fullOptions);\n    default:\n      return {};\n  }\n}\n","import mergeWithDefaultOptions from './utils/mergeWithDefaultOptions';\nimport toHiragana from './toHiragana';\nimport isKatakana from './isKatakana';\nimport { getKanaToRomajiTree } from './utils/kanaToRomajiMap';\nimport { applyMapping, mergeCustomMapping } from './utils/kanaMapping';\n\n/**\n * Convert kana to romaji\n * @param  {String} kana text input\n * @param  {DefaultOptions} [options=defaultOptions]\n * @return {String} converted text\n * @example\n * toRomaji('ひらがな　カタカナ')\n * // => 'hiragana katakana'\n * toRomaji('げーむ　ゲーム')\n * // => 'ge-mu geemu'\n * toRomaji('ひらがな　カタカナ', { upcaseKatakana: true })\n * // => 'hiragana KATAKANA'\n * toRomaji('つじぎり', { customRomajiMapping: { じ: 'zi', つ: 'tu', り: 'li' } });\n * // => 'tuzigili'\n */\nexport function toRomaji(input = '', options = {}) {\n  const mergedOptions = mergeWithDefaultOptions(options);\n  // just throw away the substring index information and just concatenate all the kana\n  return splitIntoRomaji(input, mergedOptions)\n    .map((romajiToken) => {\n      const [start, end, romaji] = romajiToken;\n      const makeUpperCase = options.upcaseKatakana && isKatakana(input.slice(start, end));\n      return makeUpperCase ? romaji.toUpperCase() : romaji;\n    })\n    .join('');\n}\n\nfunction splitIntoRomaji(input, options) {\n  let map = getKanaToRomajiTree(options);\n  map = mergeCustomMapping(map, options.customRomajiMapping);\n\n  return applyMapping(toHiragana(input, { passRomaji: true }), map, !options.IMEMode);\n}\n\nexport default toRomaji;\n","import mergeWithDefaultOptions from './utils/mergeWithDefaultOptions';\nimport hiraganaToKatakana from './utils/hiraganaToKatakana';\nimport romajiToHiragana from './utils/romajiToHiragana';\nimport isCharEnglishPunctuation from './utils/isCharEnglishPunctuation';\nimport isRomaji from './isRomaji';\nimport isMixed from './isMixed';\nimport isHiragana from './isHiragana';\n\n/**\n * Convert input to [Katakana](https://en.wikipedia.org/wiki/Katakana)\n * @param  {String} [input=''] text\n * @param  {DefaultOptions} [options=defaultOptions]\n * @return {String} converted text\n * @example\n * toKatakana('toukyou, おおさか')\n * // => 'トウキョウ、　オオサカ'\n * toKatakana('only かな', { passRomaji: true })\n * // => 'only カナ'\n * toKatakana('wi')\n * // => 'ウィ'\n * toKatakana('wi', { useObsoleteKana: true })\n * // => 'ヰ'\n */\nfunction toKatakana(input = '', options = {}) {\n  const mergedOptions = mergeWithDefaultOptions(options);\n  if (mergedOptions.passRomaji) {\n    return hiraganaToKatakana(input);\n  }\n\n  if (isMixed(input) || isRomaji(input) || isCharEnglishPunctuation(input)) {\n    const romaji = romajiToHiragana(input, mergedOptions);\n    return hiraganaToKatakana(romaji);\n  }\n\n  return hiraganaToKatakana(input);\n}\n\nexport default toKatakana;\n","import isEmpty from './isEmpty';\nimport { JA_PUNCTUATION_RANGES } from '../constants';\nimport isCharInRange from './isCharInRange';\n\n/**\n * Tests a character. Returns true if the character is considered English punctuation.\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharJapanesePunctuation(char = '') {\n  if (isEmpty(char)) return false;\n  return JA_PUNCTUATION_RANGES.some(([start, end]) => isCharInRange(char, start, end));\n}\n\nexport default isCharJapanesePunctuation;\n","import isEmpty from './isEmpty';\nimport isCharEnglishPunctuation from './isCharEnglishPunctuation';\nimport isCharJapanesePunctuation from './isCharJapanesePunctuation';\n\n/**\n * Tests a character. Returns true if the character is considered Japanese or English punctuation.\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharPunctuation(char = '') {\n  if (isEmpty(char)) return false;\n  return isCharEnglishPunctuation(char) || isCharJapanesePunctuation(char);\n}\n\nexport default isCharPunctuation;\n","import isEmpty from './utils/isEmpty';\nimport isCharKana from './utils/isCharKana';\nimport isCharPunctuation from './utils/isCharPunctuation';\nimport isJapanese from './isJapanese';\nimport isKana from './isKana';\nimport isKanji from './isKanji';\n\n/**\n * Strips trailing [Okurigana](https://en.wikipedia.org/wiki/Okurigana) if `input` is a mix of [Kanji](https://en.wikipedia.org/wiki/Kanji) and [Kana](https://en.wikipedia.org/wiki/Kana)\n * @param  {String} input text\n * @param  {Object} [options={ all: false }] config object specifying if *all* kana should be removed, not just trailing okurigana\n * @return {String} text with okurigana removed\n * @example\n * stripOkurigana('踏み込む')\n * // => '踏み込'\n * stripOkurigana('粘り。')\n * // => '粘。'\n * stripOkurigana('お祝い')\n * // => 'お祝'\n * stripOkurigana('踏み込む', { all: true })\n * // => '踏込'\n * stripOkurigana('お祝い', { all: true })\n * // => '祝'\n */\nfunction stripOkurigana(input = '', options = { all: false }) {\n  if (isEmpty(input) || !isJapanese(input) || isKana(input)) {\n    return input;\n  }\n  const chars = [...input];\n\n  // strip every kana\n  if (options.all) {\n    return chars.filter((char) => !isCharKana(char)).join('');\n  }\n\n  // strip trailing only\n  const reverseChars = chars.reverse();\n  for (let i = 0, len = reverseChars.length; i < len; i += 1) {\n    const char = reverseChars[i];\n    // pass if it's punctuation\n    if (isCharPunctuation(char)) continue; // eslint-disable-line no-continue\n    // blank out if not kanji\n    if (!isKanji(char)) {\n      reverseChars[i] = '';\n    } else break; // stop when we hit a kanji char\n  }\n\n  return reverseChars.reverse().join('');\n}\n\nexport default stripOkurigana;\n","import isEmpty from './utils/isEmpty';\nimport isCharEnglishPunctuation from './utils/isCharEnglishPunctuation';\nimport isCharJapanesePunctuation from './utils/isCharJapanesePunctuation';\nimport isCharRomaji from './utils/isCharRomaji';\nimport isCharKanji from './utils/isCharKanji';\nimport isCharHiragana from './utils/isCharHiragana';\nimport isCharKatakana from './utils/isCharKatakana';\nimport isCharJapanese from './utils/isCharJapanese';\n\nconst isCharEnSpace = (x) => x === ' ';\nconst isCharJaSpace = (x) => x === '　';\nconst isCharJaNum = (x) => /[０-９]/.test(x);\nconst isCharEnNum = (x) => /[0-9]/.test(x);\n\nexport const TOKEN_TYPES = {\n  EN: 'en',\n  JA: 'ja',\n  EN_NUM: 'englishNumeral',\n  JA_NUM: 'japaneseNumeral',\n  EN_PUNC: 'englishPunctuation',\n  JA_PUNC: 'japanesePunctuation',\n  KANJI: 'kanji',\n  HIRAGANA: 'hiragana',\n  KATAKANA: 'katakana',\n  SPACE: 'space',\n  OTHER: 'other',\n};\n\n// prettier-ignore\nexport function getType(input, compact = false) {\n  const {\n    EN, JA, EN_NUM, JA_NUM, EN_PUNC, JA_PUNC, KANJI, HIRAGANA, KATAKANA, SPACE, OTHER,\n  } = TOKEN_TYPES;\n\n  if (compact) {\n    switch (true) {\n      case isCharJaNum(input): return OTHER;\n      case isCharEnNum(input): return OTHER;\n      case isCharEnSpace(input): return EN;\n      case isCharEnglishPunctuation(input): return OTHER;\n      case isCharJaSpace(input): return JA;\n      case isCharJapanesePunctuation(input): return OTHER;\n      case isCharJapanese(input): return JA;\n      case isCharRomaji(input): return EN;\n      default: return OTHER;\n    }\n  } else {\n    switch (true) {\n      case isCharJaSpace(input): return SPACE;\n      case isCharEnSpace(input): return SPACE;\n      case isCharJaNum(input): return JA_NUM;\n      case isCharEnNum(input): return EN_NUM;\n      case isCharEnglishPunctuation(input): return EN_PUNC;\n      case isCharJapanesePunctuation(input): return JA_PUNC;\n      case isCharKanji(input): return KANJI;\n      case isCharHiragana(input): return HIRAGANA;\n      case isCharKatakana(input): return KATAKANA;\n      case isCharJapanese(input): return JA;\n      case isCharRomaji(input): return EN;\n      default: return OTHER;\n    }\n  }\n}\n\n/**\n * Splits input into array of strings separated by opinionated token types\n * 'en', 'ja', 'englishNumeral', 'japaneseNumeral',\n * 'englishPunctuation', 'japanesePunctuation',\n * 'kanji', 'hiragana', 'katakana', 'space', 'other'\n * If { compact: true } then many same-language tokens are combined (spaces + text, kanji + kana, numeral + punctuation)\n * If { detailed: true } then return array will contain { type, value } instead of 'value'\n * @param  {String} input text\n * @param  {Object} [options={ compact: false, detailed: false}] options to modify output style\n * @return {String|Object[]} text split into tokens containing values, or detailed object\n * @example\n * tokenize('ふふフフ')\n * // => ['ふふ', 'フフ']\n * tokenize('感じ')\n * // => ['感', 'じ']\n * tokenize('truly 私は悲しい')\n * // => ['truly', ' ', '私', 'は', '悲', 'しい']\n * tokenize('truly 私は悲しい', { compact: true })\n * // => ['truly ', '私は悲しい']\n * tokenize('5romaji here...!?漢字ひらがな４カタ　カナ「ＳＨＩＯ」。！')\n * // => [ '5', 'romaji', ' ', 'here', '...!?', '漢字', 'ひらがな', 'カタ', '　', 'カナ', '４', '「', 'ＳＨＩＯ', '」。！']\n * tokenize('5romaji here...!?漢字ひらがな４カタ　カナ「ＳＨＩＯ」。！', { compact: true })\n * // => [ '5', 'romaji here', '...!?', '漢字ひらがなカタ　カナ', '４「', 'ＳＨＩＯ', '」。！']\n */\nfunction tokenize(input, { compact = false, detailed = false } = {}) {\n  if (input == null || isEmpty(input)) {\n    return [];\n  }\n  const chars = [...input];\n  let initial = chars.shift();\n  let prevType = getType(initial, compact);\n  initial = detailed ? { type: prevType, value: initial } : initial;\n\n  const result = chars.reduce(\n    (tokens, char) => {\n      const currType = getType(char, compact);\n      const sameType = currType === prevType;\n      prevType = currType;\n      let newValue = char;\n\n      if (sameType) {\n        newValue = (detailed ? tokens.pop().value : tokens.pop()) + newValue;\n      }\n\n      return detailed\n        ? tokens.concat({ type: currType, value: newValue })\n        : tokens.concat(newValue);\n    },\n    [initial]\n  );\n  return result;\n}\n\nexport default tokenize;\n","export const VERSION = '3.0.1';\n\n/**\n * @typedef {Object} DefaultOptions\n * @property {Boolean} [useObsoleteKana=false] - Set to true to use obsolete characters, such as ゐ and ゑ.\n * @example\n * toHiragana('we', { useObsoleteKana: true })\n * // => 'ゑ'\n * @property {Boolean} [passRomaji=false] - Set to true to pass romaji when using mixed syllabaries with toKatakana() or toHiragana()\n * @example\n * toHiragana('only convert the katakana: ヒラガナ', { passRomaji: true })\n * // => \"only convert the katakana: ひらがな\"\n * @property {Boolean} [upcaseKatakana=false] - Set to true to convert katakana to uppercase using toRomaji()\n * @example\n * toRomaji('ひらがな カタカナ', { upcaseKatakana: true })\n * // => \"hiragana KATAKANA\"\n * @property {Boolean} [IMEMode=false] - Set to true, 'toHiragana', or 'toKatakana' to handle conversion from a text input while it is being typed.\n * @property {String} [romanization='hepburn'] - choose toRomaji() romanization map (currently only hepburn)\n * @property {Object} [customKanaMapping={}] - custom map will be merged with default conversion\n * @example\n * toKana('WanaKana', { customKanaMapping: { na: 'に', ka: 'Bana' }) };\n * // => 'ワにBanaに'\n * @property {Object} [customRomajiMapping={}] - custom map will be merged with default conversion\n * @example\n * toRomaji('つじぎり', { customRomajiMapping: { じ: 'zi', つ: 'tu', り: 'li' }) };\n * // => 'tuzigili'\n */\n\nexport const TO_KANA_METHODS = {\n  HIRAGANA: 'toHiragana',\n  KATAKANA: 'toKatakana',\n};\n\nexport const ROMANIZATIONS = Object.freeze({\n  HEPBURN: 'hepburn',\n});\n\n/**\n * Default config for WanaKana, user passed options will be merged with this\n * @type {DefaultOptions}\n * @ignore\n */\nexport const DEFAULT_OPTIONS = {\n  useObsoleteKana: false,\n  passRomaji: false,\n  upcaseKatakana: false,\n  ignoreCase: false,\n  IMEMode: false,\n  romanization: ROMANIZATIONS.HEPBURN,\n  customKanaMapping: {},\n  customRomajiMapping: {},\n};\n\n// CharCode References\n// http://www.rikai.com/library/kanjitables/kanji_codes.unicode.shtml\n// http://unicode-table.com\n\nexport const LATIN_LOWERCASE_START = 0x61;\nexport const LATIN_LOWERCASE_END = 0x7a;\nexport const LATIN_UPPERCASE_START = 0x41;\nexport const LATIN_UPPERCASE_END = 0x5a;\nexport const LOWERCASE_ZENKAKU_START = 0xff41;\nexport const LOWERCASE_ZENKAKU_END = 0xff5a;\nexport const UPPERCASE_ZENKAKU_START = 0xff21;\nexport const UPPERCASE_ZENKAKU_END = 0xff3a;\nexport const HIRAGANA_START = 0x3041;\nexport const HIRAGANA_END = 0x3096;\nexport const KATAKANA_START = 0x30a1;\nexport const KATAKANA_END = 0x30fc;\nexport const KANJI_START = 0x4e00;\nexport const KANJI_END = 0x9faf;\nexport const PROLONGED_SOUND_MARK = 0x30fc;\nexport const KANA_SLASH_DOT = 0x30fb;\n\nconst ZENKAKU_NUMBERS = [0xff10, 0xff19];\nconst ZENKAKU_UPPERCASE = [UPPERCASE_ZENKAKU_START, UPPERCASE_ZENKAKU_END];\nconst ZENKAKU_LOWERCASE = [LOWERCASE_ZENKAKU_START, LOWERCASE_ZENKAKU_END];\nconst ZENKAKU_PUNCTUATION_1 = [0xff01, 0xff0f];\nconst ZENKAKU_PUNCTUATION_2 = [0xff1a, 0xff1f];\nconst ZENKAKU_PUNCTUATION_3 = [0xff3b, 0xff3f];\nconst ZENKAKU_PUNCTUATION_4 = [0xff5b, 0xff60];\nconst ZENKAKU_SYMBOLS_CURRENCY = [0xffe0, 0xffee];\n\nconst HIRAGANA_CHARS = [0x3040, 0x309f];\nconst KATAKANA_CHARS = [0x30a0, 0x30ff];\nconst HANKAKU_KATAKANA = [0xff66, 0xff9f];\nconst KATAKANA_PUNCTUATION = [0x30fb, 0x30fc];\nconst KANA_PUNCTUATION = [0xff61, 0xff65];\nconst CJK_SYMBOLS_PUNCTUATION = [0x3000, 0x303f];\nconst COMMON_CJK = [0x4e00, 0x9fff];\nconst RARE_CJK = [0x3400, 0x4dbf];\n\nexport const KANA_RANGES = [HIRAGANA_CHARS, KATAKANA_CHARS, KANA_PUNCTUATION, HANKAKU_KATAKANA];\n\nexport const JA_PUNCTUATION_RANGES = [\n  CJK_SYMBOLS_PUNCTUATION,\n  KANA_PUNCTUATION,\n  KATAKANA_PUNCTUATION,\n  ZENKAKU_PUNCTUATION_1,\n  ZENKAKU_PUNCTUATION_2,\n  ZENKAKU_PUNCTUATION_3,\n  ZENKAKU_PUNCTUATION_4,\n  ZENKAKU_SYMBOLS_CURRENCY,\n];\n\n/**\n * All Japanese unicode start and end ranges\n * Includes kanji, full-width latin chars, punctuation, and number ranges.\n * @type {Array}\n * @ignore\n */\nexport const JAPANESE_RANGES = [\n  ...KANA_RANGES,\n  ...JA_PUNCTUATION_RANGES,\n  ZENKAKU_UPPERCASE,\n  ZENKAKU_LOWERCASE,\n  ZENKAKU_NUMBERS,\n  COMMON_CJK,\n  RARE_CJK,\n];\n\nconst MODERN_ENGLISH = [0x0000, 0x007f];\nconst HEPBURN_MACRON_RANGES = [\n  [0x0100, 0x0101], // Ā ā\n  [0x0112, 0x0113], // Ē ē\n  [0x012a, 0x012b], // Ī ī\n  [0x014c, 0x014d], // Ō ō\n  [0x016a, 0x016b], // Ū ū\n];\nconst SMART_QUOTE_RANGES = [\n  [0x2018, 0x2019], // ‘ ’\n  [0x201c, 0x201d], // “ ”\n];\n\nexport const ROMAJI_RANGES = [MODERN_ENGLISH, ...HEPBURN_MACRON_RANGES];\n\nexport const EN_PUNCTUATION_RANGES = [\n  [0x20, 0x2f],\n  [0x3a, 0x3f],\n  [0x5b, 0x60],\n  [0x7b, 0x7e],\n  ...SMART_QUOTE_RANGES,\n];\n","import { DEFAULT_OPTIONS } from '../constants';\n/**\n * Easy re-use of merging with default options\n * @param {Object} opts user options\n * @returns user options merged over default options\n */\nconst mergeWithDefaultOptions = (opts = {}) => Object.assign({}, DEFAULT_OPTIONS, opts);\n\nexport default mergeWithDefaultOptions;\n","/* eslint-disable no-console */\nconst onInput = ({ target }) => console.log(`input: ${target.value}`);\nconst onTextInput = ({ target }) => console.log(`textinput: ${target.value}`);\nconst onKeyDown = ({ key, which }) => {\n  const char = String.fromCharCode(which);\n  const message = `which: ${which} ${/[a-z]/i.test(char) ? `char: ${char}` : ''}`;\n  console.log(`$keydown: ${message}`);\n};\nconst onCompositionStart = () => console.log('compositionstart');\nconst onCompositionEnd = () => console.log('compositionend');\nconst onCompositionUpdate = ({ data }) => console.log(`compositionupdate: data: ${data}`);\n\nconst events = {\n  input: onInput,\n  textinput: onTextInput,\n  keydown: onKeyDown,\n  compositionstart: onCompositionStart,\n  compositionend: onCompositionEnd,\n  compositionupdate: onCompositionUpdate,\n};\n\nexport const addDebugListeners = (input) => {\n  Object.entries(events).forEach(([event, handler]) => input.addEventListener(event, handler));\n};\n\nexport const removeDebugListeners = (input) => {\n  Object.entries(events).forEach(([event, handler]) => input.removeEventListener(event, handler));\n};\n"],"names":["typeOf","value","Object","toString","call","slice","toLowerCase","isEmpty","input","length","isCharInRange","char","start","end","code","charCodeAt","isCharJapanese","JAPANESE_RANGES","some","isJapanese","allowed","augmented","every","isJa","test","applyMapping","string","mapping","convertEnding","nextSubtree","tree","nextChar","undefined","assign","newChunk","remaining","currentCursor","firstChar","charAt","parse","root","lastCursor","keys","concat","subtree","transform","result","_objectEntries","getSubTreeOf","correctSubTree","createCustomMapping","customMap","customTree","rom","kan","subTree","map","transformMap","mapSubtree","customSubtree","JSON","stringify","mergeCustomMapping","customMapping","createRomajiToKanaMap","addTsu","key","kanaTree","a","u","o","subtreeOf","consonants","smallY","smallaiueo","consonant","yKana","specialSymbols","symbol","jsymbol","aiueoConstructions","aiueoKan","vow","alternativeMappings","c","k","alternative","allExceptLast","last","smallLetters","kunreiRom","xSubtree","alt","startsWith","push","replace","altRom","prefix","individualCases","kana","n","freeze","getRomajiToKanaTree","config","romajiToKanaMap","IME_MODE_MAP","mapCopy","isCharUpperCase","LATIN_UPPERCASE_START","LATIN_UPPERCASE_END","isCharLongDash","PROLONGED_SOUND_MARK","isCharSlashDot","KANA_SLASH_DOT","isCharHiragana","HIRAGANA_START","HIRAGANA_END","hiraganaToKatakana","kata","split","forEach","KATAKANA_START","kataChar","String","fromCharCode","join","toKana","options","splitIntoConvertedKana","kanaToken","IMEMode","useObsoleteKana","USE_OBSOLETE_KANA_MAP","customKanaMapping","mergeWithDefaultOptions","makeOnInput","el","mergedConfig","target","dataset","selectionEnd","isComposing","log","splitInput","head","textToConvert","tail","convertedText","newCursor","setSelectionRange","onComposition","type","isChrome","window","chrome","webstore","inputEvent","Event","dispatchEvent","trackListeners","id","inputHandler","compositionHandler","LISTENERS","untrackListeners","targetId","filter","findListeners","find","getAttribute","text","startIndex","toConvert","triggers","toUpperCase","includes","workFromStart","workBackwards","takeWhileAndSlice","setKanaType","catalystChars","reverse","source","predicate","x","i","TO_KANA_METHODS","HIRAGANA","KATAKANA","bind","debug","ELEMENTS","nodeName","Error","onInput","newId","setAttribute","addEventListener","unbind","listeners","removeAttribute","removeEventListener","isCharRomaji","ROMAJI_RANGES","isRomaji","isRoma","isCharKatakana","KATAKANA_END","isCharKana","isKana","isHiragana","isKatakana","isCharKanji","KANJI_START","KANJI_END","isKanji","isMixed","passKanji","chars","hasKanji","katakanaToHiragana","hira","previousKana","iterable","index","isCharInitialLongDash","isKanaAsSymbol","isCharInnerLongDash","romaji","toRomaji","LONG_VOWELS","hiraChar","romajiToHiragana","isCharEnglishPunctuation","EN_PUNCTUATION_RANGES","toHiragana","passRomaji","createKanaToHepburnMap","resolveTsu","sokuonWhitelist","romajiTree","setTrans","transliteration","ゃ","ゅ","ょ","smallYExtra","ぃ","ぇ","ぁ","ぅ","ぉ","yoonKana","fistRomajiLetter","yoonExceptions","し","ち","じ","ぢ","ambig","getKanaToHepburnTree","kanaToHepburnMap","getKanaToRomajiTree","fullOptions","romanization","ROMANIZATIONS","HEPBURN","mergedOptions","splitIntoRomaji","romajiToken","upcaseKatakana","customRomajiMapping","toKatakana","isCharJapanesePunctuation","JA_PUNCTUATION_RANGES","isCharPunctuation","stripOkurigana","all","reverseChars","len","getType","compact","EN","TOKEN_TYPES","JA","EN_NUM","JA_NUM","EN_PUNC","JA_PUNC","KANJI","SPACE","OTHER","isCharJaNum","isCharEnNum","isCharEnSpace","isCharJaSpace","tokenize","detailed","initial","shift","prevType","reduce","tokens","currType","sameType","newValue","pop","DEFAULT_OPTIONS","ZENKAKU_NUMBERS","ZENKAKU_UPPERCASE","ZENKAKU_LOWERCASE","KANA_PUNCTUATION","COMMON_CJK","RARE_CJK","KANA_RANGES","HEPBURN_MACRON_RANGES","SMART_QUOTE_RANGES","opts","wi","we","events","console","which","message","data","addDebugListeners","event","handler","removeDebugListeners","idCounter","Date","now"],"mappings":"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"}