import simulant from 'jsdom-simulant';

import { TO_KANA_METHODS } from '../src/constants';

import { ROMA_TO_HIRA_KATA, HIRA_KATA_TO_ROMA, JA_PUNC, EN_PUNC } from './helpers/testTables';

import isKana from '../src/isKana';
import isKanji from '../src/isKanji';
import isJapanese from '../src/isJapanese';
import isKatakana from '../src/isKatakana';
import isHiragana from '../src/isHiragana';
import isRomaji from '../src/isRomaji';
import isMixed from '../src/isMixed';
import { toKana, splitIntoKana } from '../src/toKana';
import toKatakana from '../src/toKatakana';
import toHiragana from '../src/toHiragana';
import toRomaji from '../src/toRomaji';
import stripOkurigana from '../src/stripOkurigana';
import tokenize from '../src/tokenize';
import bind from '../src/bind';
import unbind from '../src/unbind';
import { createCustomMapping } from '../src/utils/kanaMappingUtils';

describe('Methods should return valid defaults when given no input', () => {
  it('isKana() with no input', () => expect(isKana()).toBe(false));
  it('isKanji() with no input', () => expect(isKanji()).toBe(false));
  it('isJapanese() with no input', () => expect(isJapanese()).toBe(false));
  it('isKatakana() with no input', () => expect(isKatakana()).toBe(false));
  it('isHiragana() with no input', () => expect(isHiragana()).toBe(false));
  it('isRomaji() with no input', () => expect(isRomaji()).toBe(false));
  it('isMixed() with no input', () => expect(isMixed()).toBe(false));
  it('toKana() with no input', () => expect(toKana()).toBe(''));
  it('splitIntoKana() with no input', () => expect(splitIntoKana()).toEqual([]));
  it('toKatakana() with no input', () => expect(toKatakana()).toBe(''));
  it('toHiragana() with no input', () => expect(toHiragana()).toBe(''));
  it('toRomaji() with no input', () => expect(toRomaji()).toBe(''));
  it('stripOkurigana() with no input', () => expect(stripOkurigana()).toBe(''));
  it('tokenize() with no input', () => expect(tokenize()).toEqual(['']));
});

describe('Character type detection', () => {
  describe('isHiragana()', () => {
    it('„ÅÇ is hiragana', () => expect(isHiragana('„ÅÇ')).toBe(true));
    it('„ÅÇ„ÅÇ is hiragana', () => expect(isHiragana('„ÅÇ„ÅÇ')).toBe(true));
    it('„Ç¢ is not hiragana', () => expect(isHiragana('„Ç¢')).toBe(false));
    it('A is not hiragana', () => expect(isHiragana('A')).toBe(false));
    it('„ÅÇ„Ç¢ is not hiragana', () => expect(isHiragana('„ÅÇ„Ç¢')).toBe(false));
    it('ignores long dash in hiragana', () => expect(isHiragana('„Åí„Éº„ÇÄ')).toBe(true));
  });

  describe('isKatakana()', () => {
    it('„Ç¢„Ç¢ is katakana', () => expect(isKatakana('„Ç¢„Ç¢')).toBe(true));
    it('„Ç¢ is katakana', () => expect(isKatakana('„Ç¢')).toBe(true));
    it('„ÅÇ is not katakana', () => expect(isKatakana('„ÅÇ')).toBe(false));
    it('A is not katakana', () => expect(isKatakana('A')).toBe(false));
    it('„ÅÇ„Ç¢ is not katakana', () => expect(isKatakana('„ÅÇ„Ç¢')).toBe(false));
    it('ignores long dash in katakana', () => expect(isKatakana('„Ç≤„Éº„É†')).toBe(true));
  });

  describe('isKana()', () => {
    it('„ÅÇ is kana', () => expect(isKana('„ÅÇ')).toBe(true));
    it('„Ç¢ is kana', () => expect(isKana('„Ç¢')).toBe(true));
    it('„ÅÇ„Ç¢ is kana', () => expect(isKana('„ÅÇ„Ç¢')).toBe(true));
    it('A is not kana', () => expect(isKana('A')).toBe(false));
    it('„ÅÇA„Ç¢ is not kana', () => expect(isKana('„ÅÇA„Ç¢')).toBe(false));
    it('ignores long dash in mixed kana', () => expect(isKana('„Ç¢„Éº„ÅÇ')).toBe(true));
  });

  describe('isKanji()', () => {
    it('ÂàáËÖπ is kanji', () => expect(isKanji('ÂàáËÖπ')).toBe(true));
    it('ÂàÄ is kanji', () => expect(isKanji('ÂàÄ')).toBe(true));
    it('üê∏ is not kanji', () => expect(isKanji('üê∏')).toBe(false));
    it('„ÅÇ is not kanji', () => expect(isKanji('„ÅÇ')).toBe(false));
    it('„Ç¢ is not kanji', () => expect(isKanji('„Ç¢')).toBe(false));
    it('„ÅÇ„Ç¢ is not kanji', () => expect(isKanji('„ÅÇ„Ç¢')).toBe(false));
    it('A is not kanji', () => expect(isKanji('A')).toBe(false));
    it('„ÅÇA„Ç¢ is not kanji', () => expect(isKanji('„ÅÇA„Ç¢')).toBe(false));
    it('ÔºëÔºíÈöª is not kanji', () => expect(isKanji('ÔºëÔºíÈöª')).toBe(false));
    it('12Èöª is not kanji', () => expect(isKanji('12Èöª')).toBe(false));
    it('Èöª„ÄÇ is not kanji', () => expect(isKanji('Èöª„ÄÇ')).toBe(false));
  });

  describe('isJapanese()', () => {
    it('Ê≥£„ÅçËô´ is japanese', () => expect(isJapanese('Ê≥£„ÅçËô´')).toBe(true));
    it('„ÅÇ„Ç¢ is japanese', () => expect(isJapanese('„ÅÇ„Ç¢')).toBe(true));
    it('AÊ≥£„ÅçËô´ is not japanese', () => expect(isJapanese('AÊ≥£„ÅçËô´')).toBe(false));
    it('A is not japanese', () => expect(isJapanese('A')).toBe(false));
    it('ja space is japanese', () => expect(isJapanese('„ÄÄ')).toBe(true));
    it('en space is not japanese', () => expect(isJapanese(' ')).toBe(false));
    it('Ê≥£„ÅçËô´„ÄÇÔºÅ„Äú (w. zenkaku punctuation) is japanese', () =>
      expect(isJapanese('Ê≥£„ÅçËô´„ÄÇÔºÉÔºÅ„Äú„Äà„Äâ„Ää„Äã„Äî„ÄïÔºªÔºΩ„Äê„ÄëÔºàÔºâÔΩõÔΩù„Äù„Äü')).toBe(true));
    it('Ê≥£„ÅçËô´.!~ (w. romaji punctuation) is not japanese', () =>
      expect(isJapanese('Ê≥£„ÅçËô´.!~')).toBe(false));
    it('zenkaku numbers are considered neutral', () =>
      expect(isJapanese('ÔºêÔºëÔºíÔºìÔºîÔºïÔºñÔºóÔºòÔºô')).toBe(true));
    it('latin numbers are considered neutral', () => expect(isJapanese('0123456789')).toBe(true));
    it('zenkaku latin letters are considered neutral', () => expect(isJapanese('Ôº≠ÔΩÖÔº¥ÔΩèÔΩè')).toBe(true));
    it('mixed with numbers is japanese', () => expect(isJapanese('ÔºíÔºêÔºëÔºëÂπ¥')).toBe(true));
    it('hankaku katakana is allowed', () => expect(isJapanese('ÔæäÔæùÔΩ∂ÔΩ∏ÔΩ∂ÔæÄÔΩ∂ÔæÖ')).toBe(true));
    it('randomly selected web text is japanese', () =>
      expect(
        isJapanese(
          'ÔºÉÔº≠ÔΩÖÔº¥ÔΩèÔΩè„ÄÅ„Åì„Çå„ÇíÂâç„Å´„ÄåÔº´ÔºµÔº≤ÔºØÔº≥Ôº®Ôº©ÔºØ„Äç„ÅØ„ÄÅÈÉΩÂÜÖ„ÅßÂ†±ÈÅìÈô£„ÇíÂâç„Å´Ê∞¥‰∏≠Êé¢Êüª„É≠„Éú„ÉÉ„Éà„ÅÆÊúÄÁµÇÁÇπÊ§ú„ÅÆÊßòÂ≠ê„ÇíÂÖ¨Èñã„Åó„Åæ„Åó„Åü„ÄÇ„Ç§„É´„Ç´„ÅÆ„Çà„ÅÜ„Å™ÂΩ¢„Çí„Åó„ÅüÊé¢Êüª„É≠„Éú„ÉÉ„Éà„ÅØ„ÄÅÂÖ®Èï∑Ôºì„É°„Éº„Éà„É´„ÄÅÈáç„Åï„ÅØÔºìÔºïÔºê„Ç≠„É≠„ÅÇ„Çä„Åæ„Åô„ÄÇ„Ää„ÅØ„Åò„ÇÅ„Å´„ÄãÂÜíÈ†≠„ÄÅÂÆâÂÄçÁ∑èÁêÜÂ§ßËá£„ÅØ„ÄÅ„Åì„Å®„Åó„ÅåÊòéÊ≤ªÂÖÉÂπ¥„Åã„ÇâÔºëÔºïÔºêÂπ¥„Å´„ÅÇ„Åü„Çã„Åì„Å®„Å´Ëß¶„Çå„ÄåÊòéÊ≤ª„Å®„ÅÑ„ÅÜÊñ∞„Åó„ÅÑÊôÇ‰ª£„ÅåËÇ≤„Å¶„Åü„ÅÇ„Åæ„Åü„ÅÆ‰∫∫Êùê„Åå„ÄÅÊäÄË°ìÂÑ™‰Ωç„ÅÆÊ¨ßÁ±≥Ë´∏ÂõΩ„ÅåËø´„Çã„ÄéÂõΩÈõ£„Äè„Å®„ÇÇÂëº„Å∂„Åπ„ÅçÂç±Ê©ü„ÅÆ‰∏≠„Åß„ÄÅ„Çè„ÅåÂõΩ„ÅåÊÄ•ÈÄü„Å´Ëøë‰ª£Âåñ„ÇíÈÅÇ„Åí„ÇãÂéüÂãïÂäõ„Å®„Å™„Å£„Åü„ÄÇ‰ªä„Åæ„Åü„ÄÅÊó•Êú¨„ÅØÂ∞ëÂ≠êÈ´òÈΩ¢Âåñ„Å®„ÅÑ„ÅÜ„ÄéÂõΩÈõ£„Äè„Å®„ÇÇÂëº„Å∂„Åπ„ÅçÂç±Ê©ü„Å´Áõ¥Èù¢„Åó„Å¶„ÅÑ„Çã„ÄÇ„ÇÇ„ÅÜÔºëÂ∫¶„ÄÅ„ÅÇ„Çâ„ÇÜ„ÇãÊó•Êú¨‰∫∫„Å´„ÉÅ„É£„É≥„Çπ„ÇíÂâµ„Çã„Åì„Å®„Åß„ÄÅÂ∞ëÂ≠êÈ´òÈΩ¢Âåñ„ÇÇÂÖãÊúç„Åß„Åç„Çã„Äç„Å®Âëº„Å≥„Åã„Åë„Åæ„Åó„Åü„ÄÇ„ÄäÂÉç„ÅçÊñπÊîπÈù©„ÄãÁ∂ö„ÅÑ„Å¶ÂÆâÂÄçÁ∑èÁêÜÂ§ßËá£„ÅØ„ÄÅÂÖ∑‰ΩìÁöÑ„Å™ÊîøÁ≠ñË™≤È°å„ÅÆÊúÄÂàù„Å´„ÄåÂÉç„ÅçÊñπÊîπÈù©„Äç„ÇíÂèñ„Çä‰∏ä„Åí„ÄÅ„ÄåÊà¶Âæå„ÅÆÂä¥ÂÉçÂü∫Ê∫ñÊ≥ïÂà∂ÂÆö‰ª•Êù•„ÄÅÔºóÔºêÂπ¥„Å∂„Çä„ÅÆÂ§ßÊîπÈù©„Å†„ÄÇË™∞„ÇÇ„ÅåÁîü„Åç„Åå„ÅÑ„ÇíÊÑü„Åò„Å¶„ÄÅ„Åù„ÅÆËÉΩÂäõ„ÇíÊÄù„ÅÜÂ≠òÂàÜÁô∫ÊèÆ„Åô„Çå„Å∞Â∞ëÂ≠êÈ´òÈΩ¢Âåñ„ÇÇÂÖãÊúç„Åß„Åç„Çã„Äç„Å®Ëø∞„Åπ„Åæ„Åó„Åü„ÄÇ„Åù„Åó„Å¶„ÄÅÂêå‰∏ÄÂä¥ÂÉçÂêå‰∏ÄË≥ÉÈáë„ÅÆÂÆüÁèæ„ÇÑ„ÄÅÊôÇÈñìÂ§ñÂä¥ÂÉç„ÅÆ‰∏äÈôêË¶èÂà∂„ÅÆÂ∞éÂÖ•„ÄÅ„Åù„Çå„Å´Âä¥ÂÉçÊôÇÈñì„Åß„Å™„ÅèÊàêÊûú„ÅßË©ï‰æ°„Åô„Çã„Å®„Åó„Å¶Âä¥ÂÉçÊôÇÈñì„ÅÆË¶èÂà∂„Åã„ÇâÂ§ñ„Åô„ÄåÈ´òÂ∫¶„Éó„É≠„Éï„Çß„ÉÉ„Ç∑„Éß„Éä„É´Âà∂Â∫¶„Äç„ÅÆÂâµË®≠„Å™„Å©„Å´Âèñ„ÇäÁµÑ„ÇÄËÄÉ„Åà„ÇíÂº∑Ë™ø„Åó„Åæ„Åó„Åü„ÄÇ'
        )
      ).toBe(true));
  });

  describe('isRomaji()', () => {
    it('A is romaji', () => expect(isRomaji('A')).toBe(true));
    it('xYz is romaji', () => expect(isRomaji('xYz')).toBe(true));
    it('T≈çky≈ç and ≈åsaka is romaji', () => expect(isRomaji('T≈çky≈ç and ≈åsaka')).toBe(true));
    it('„ÅÇ„Ç¢A is not romaji', () => expect(isRomaji('„ÅÇ„Ç¢A')).toBe(false));
    it('„ÅäÈ°ò„ÅÑ is not romaji', () => expect(isRomaji('„ÅäÈ°ò„ÅÑ')).toBe(false));
    it('ÁÜüÊàê is not romaji', () => expect(isRomaji('ÁÜüÊàê')).toBe(false));
    it('passes latin punctuation', () => expect(isRomaji('a*b&c-d')).toBe(true));
    it('passes latin numbers', () => expect(isRomaji('0123456789')).toBe(true));
    it('fails zenkaku punctuation', () => expect(isRomaji('aÔºÅb&c„Éºd')).toBe(false));
    it('fails zenkaku latin', () => expect(isRomaji('ÔΩàÔΩÖÔΩåÔΩåÔΩè')).toBe(false));
  });

  describe('isMixed()', () => {
    it('A„Ç¢ is mixed', () => expect(isMixed('A„Ç¢')).toBe(true));
    it('A„ÅÇ is mixed', () => expect(isMixed('A„ÅÇ')).toBe(true));
    it('A„ÅÇ„Ç¢ is mixed', () => expect(isMixed('A„ÅÇ„Ç¢')).toBe(true));
    it('Ôºí„ÅÇ„Ç¢ is not mixed', () => expect(isMixed('Ôºí„ÅÇ„Ç¢')).toBe(false));
    it('„ÅäËÖπA is mixed', () => expect(isMixed('„ÅäËÖπA')).toBe(true));
    it('„ÅäËÖπA is not mixed when { passKanji: false }', () =>
      expect(isMixed('„ÅäËÖπA', { passKanji: false })).toBe(false));
    it('„ÅäËÖπ is not mixed', () => expect(isMixed('„ÅäËÖπ')).toBe(false));
    it('ËÖπ is not mixed', () => expect(isMixed('ËÖπ')).toBe(false));
    it('A is not mixed', () => expect(isMixed('A')).toBe(false));
    it('„ÅÇ is not mixed', () => expect(isMixed('„ÅÇ')).toBe(false));
    it('„Ç¢ is not mixed', () => expect(isMixed('„Ç¢')).toBe(false));
  });
});

describe('Character conversion', () => {
  describe('Quick Brown Fox - Romaji to Hiragana', () => {
    const options = { useObsoleteKana: true };
    // https://en.wikipedia.org/wiki/Iroha
    // Even the colorful fragrant flowers'
    expect(toHiragana('IROHANIHOHETO', options)).toBe('„ÅÑ„Çç„ÅØ„Å´„Åª„Å∏„Å®');
    // die sooner or later.'
    expect(toHiragana('CHIRINURUWO', options)).toBe('„Å°„Çä„Å¨„Çã„Çí');
    // Us who live in this world'
    expect(toHiragana('WAKAYOTARESO', options)).toBe('„Çè„Åã„Çà„Åü„Çå„Åù');
    // cannot live forever, either.'
    expect(toHiragana('TSUNENARAMU', options)).toBe('„Å§„Å≠„Å™„Çâ„ÇÄ');
    // This transient mountain with shifts and changes,'
    expect(toHiragana('UWINOOKUYAMA', options)).toBe('„ÅÜ„Çê„ÅÆ„Åä„Åè„ÇÑ„Åæ');
    // today we are going to overcome, and reach the world of enlightenment.'
    expect(toHiragana('KEFUKOETE', options)).toBe('„Åë„Åµ„Åì„Åà„Å¶');
    // We are not going to have meaningless dreams'
    expect(toHiragana('ASAKIYUMEMISHI', options)).toBe('„ÅÇ„Åï„Åç„ÇÜ„ÇÅ„Åø„Åó');
    // nor become intoxicated with the fake world anymore.'
    expect(toHiragana('WEHIMOSESU', options)).toBe('„Çë„Å≤„ÇÇ„Åõ„Åô');
    // *not in iroha*
    expect(toHiragana('NLTU')).toBe('„Çì„Å£');
  });

  describe('Test every character with toKana(), toHiragana(), and toKatakana()', () => {
    describe('toKana()', () => {
      ROMA_TO_HIRA_KATA.forEach((item) => {
        const [romaji, hiragana, katakana] = item;
        const lower = toKana(romaji);
        const upper = toKana(romaji.toUpperCase());
        it(`${romaji}`, () => expect(lower).toBe(hiragana));
        it(`${romaji.toUpperCase()}`, () => expect(upper).toBe(katakana));
      });
    });

    describe('toHiragana()', () => {
      ROMA_TO_HIRA_KATA.forEach((item) => {
        const [romaji, hiragana] = item;
        const lower = toHiragana(romaji);
        const upper = toHiragana(romaji.toUpperCase());
        it(`${romaji}`, () => expect(lower).toBe(hiragana));
        it(`${romaji.toUpperCase()}`, () => expect(upper).toBe(hiragana));
      });
    });

    describe('toKatakana()', () => {
      ROMA_TO_HIRA_KATA.forEach((item) => {
        const [romaji, , katakana] = item;
        const lower = toKatakana(romaji);
        const upper = toKatakana(romaji.toUpperCase());
        it(`${romaji}`, () => expect(lower).toBe(katakana));
        it(`${romaji.toUpperCase()}`, () => expect(upper).toBe(katakana));
      });
    });
  });

  describe('Test custom mappings options', () => {
    it('applies customKanaMapping', () => {
      expect(
        toKana('WanaKana', {
          customKanaMapping: createCustomMapping({ na: '„Å´', ka: 'Bana' }),
        })
      ).toBe('„ÉØ„Å´Bana„Å´');
    })

    it("can't romanize with an invalid method", () => {
      expect(toRomaji('„Å§„Åò„Åé„Çä', { romanization: "it's called r≈çmaji!!!" })).toBe('„Å§„Åò„Åé„Çä');
    });

    it('applies customRomajiMapping', () => {
      expect(
        toRomaji('„Å§„Åò„Åé„Çä', {
          customRomajiMapping: createCustomMapping({ „Åò: 'zi', „Å§: 'tu', „Çä: 'li' }),
        })
      ).toBe('tuzigili');
    })

    it('will accept a plain object and merge it internally via createCustomMapping()', () => {
      expect(
        toKana('WanaKana', {
          customKanaMapping: { na: '„Å´', ka: 'Bana' },
        })
      ).toBe('„ÉØ„Å´Bana„Å´');

      expect(
        toRomaji('„Å§„Åò„Åé„Çä', {
          customRomajiMapping: { „Åò: 'zi', „Å§: 'tu', „Çä: 'li' },
        })
      ).toBe('tuzigili');

    });
  });

  describe('toKana()', () => {
    it('Lowercase characters are transliterated to hiragana.', () =>
      expect(toKana('onaji')).toBe('„Åä„Å™„Åò'));

    it('Lowercase with double consonants and double vowels are transliterated to hiragana.', () =>
      expect(toKana('buttsuuji')).toBe('„Å∂„Å£„Å§„ÅÜ„Åò'));

    it('Uppercase characters are transliterated to katakana.', () =>
      expect(toKana('ONAJI')).toBe('„Ç™„Éä„Ç∏'));

    it('Uppercase with double consonants and double vowels are transliterated to katakana.', () =>
      expect(toKana('BUTTSUUJI')).toBe('„Éñ„ÉÉ„ÉÑ„Ç¶„Ç∏'));

    it('WaniKani -> „ÉØ„Å´„Ç´„Å´ - Mixed case uses the first character for each syllable.', () =>
      expect(toKana('WaniKani')).toBe('„ÉØ„Å´„Ç´„Å´'));

    it('Non-romaji will be passed through.', () =>
      expect(toKana('„ÉØ„Éã„Ç´„Éã AiUeO È∞êËüπ 12345 @#$%')).toBe('„ÉØ„Éã„Ç´„Éã „Ç¢„ÅÑ„Ç¶„Åà„Ç™ È∞êËüπ 12345 @#$%'));

    it('It handles mixed syllabaries', () =>
      expect(toKana('Â∫ßÁ¶Ö‚Äòzazen‚Äô„Çπ„Çø„Ç§„É´')).toBe('Â∫ßÁ¶Ö„Äå„Åñ„Åú„Çì„Äç„Çπ„Çø„Ç§„É´'));

    it('Will convert short to long dashes', () => expect(toKana('batsuge-mu')).toBe('„Å∞„Å§„Åí„Éº„ÇÄ'));

    it('Will convert punctuation but pass through spaces', () =>
      expect(toKana(EN_PUNC.join(' '))).toBe(JA_PUNC.join(' ')));
  });

  describe('splitIntoKana()', () => {
    it('Lowercase characters are transliterated to hiragana.', () =>
      expect(splitIntoKana('onaji')).toEqual([[0, 1, '„Åä'], [1, 3, '„Å™'], [3, 5, '„Åò']]));

    it('Lowercase with double consonants and double vowels are transliterated to hiragana.', () =>
      expect(splitIntoKana('buttsuuji')).toEqual([
        [0, 2, '„Å∂'],
        [2, 6, '„Å£„Å§'],
        [6, 7, '„ÅÜ'],
        [7, 9, '„Åò'],
      ]));

    it('Non-romaji will be passed through.', () =>
      expect(splitIntoKana('„ÉØ„Éã„Ç´„Éã AiUeO È∞êËüπ 12345 @#$%')).toEqual([
        [0, 1, '„ÉØ'],
        [1, 2, '„Éã'],
        [2, 3, '„Ç´'],
        [3, 4, '„Éã'],
        [4, 5, ' '],
        [5, 6, '„ÅÇ'],
        [6, 7, '„ÅÑ'],
        [7, 8, '„ÅÜ'],
        [8, 9, '„Åà'],
        [9, 10, '„Åä'],
        [10, 11, ' '],
        [11, 12, 'È∞ê'],
        [12, 13, 'Ëüπ'],
        [13, 14, ' '],
        [14, 15, '1'],
        [15, 16, '2'],
        [16, 17, '3'],
        [17, 18, '4'],
        [18, 19, '5'],
        [19, 20, ' '],
        [20, 21, '@'],
        [21, 22, '#'],
        [22, 23, '$'],
        [23, 24, '%'],
      ]));

    it('It handles mixed syllabaries', () =>
      expect(splitIntoKana('Â∫ßÁ¶Ö‚Äòzazen‚Äô„Çπ„Çø„Ç§„É´')).toEqual([
        [0, 1, 'Â∫ß'],
        [1, 2, 'Á¶Ö'],
        [2, 3, '„Äå'],
        [3, 5, '„Åñ'],
        [5, 7, '„Åú'],
        [7, 8, '„Çì'],
        [8, 9, '„Äç'],
        [9, 10, '„Çπ'],
        [10, 11, '„Çø'],
        [11, 12, '„Ç§'],
        [12, 13, '„É´'],
      ]));

    it('Will convert short to long dashes', () =>
      expect(splitIntoKana('batsuge-mu')).toEqual([
        [0, 2, '„Å∞'],
        [2, 5, '„Å§'],
        [5, 7, '„Åí'],
        [7, 8, '„Éº'],
        [8, 10, '„ÇÄ'],
      ]));

    it('Will convert punctuation but pass through spaces', () =>
      expect(splitIntoKana(EN_PUNC.join(' '))).toEqual([
        [0, 1, 'ÔºÅ'],
        [1, 2, ' '],
        [2, 3, 'Ôºü'],
        [3, 4, ' '],
        [4, 5, '„ÄÇ'],
        [5, 6, ' '],
        [6, 7, 'Ôºö'],
        [7, 8, ' '],
        [8, 9, '„Éª'],
        [9, 10, ' '],
        [10, 11, '„ÄÅ'],
        [11, 12, ' '],
        [12, 13, '„Äú'],
        [13, 14, ' '],
        [14, 15, '„Éº'],
        [15, 16, ' '],
        [16, 17, '„Äå'],
        [17, 18, ' '],
        [18, 19, '„Äç'],
        [19, 20, ' '],
        [20, 21, '„Äé'],
        [21, 22, ' '],
        [22, 23, '„Äè'],
        [23, 24, ' '],
        [24, 25, 'Ôºª'],
        [25, 26, ' '],
        [26, 27, 'ÔºΩ'],
        [27, 28, ' '],
        [28, 29, 'Ôºà'],
        [29, 30, ' '],
        [30, 31, 'Ôºâ'],
        [31, 32, ' '],
        [32, 33, 'ÔΩõ'],
        [33, 34, ' '],
        [34, 35, 'ÔΩù'],
      ]));
  });

  describe('Converting kana to kana', () => {
    it('k -> h', () => expect(toHiragana('„Éê„Ç±„É´')).toBe('„Å∞„Åë„Çã'));
    it('h -> k', () => expect(toKatakana('„Å∞„Åë„Çã')).toBe('„Éê„Ç±„É´'));

    it('It survives only katakana toKatakana', () =>
      expect(toKatakana('„Çπ„Çø„Ç§„É´')).toBe('„Çπ„Çø„Ç§„É´'));
    it('It survives only hiragana toHiragana', () =>
      expect(toHiragana('„Åô„Åü„Éº„ÅÑ„Çã')).toBe('„Åô„Åü„Éº„ÅÑ„Çã'));
    it('Mixed kana converts every char k -> h', () =>
      expect(toKatakana('„Ç¢„É°„É™„Ç´„Åò„Çì')).toBe('„Ç¢„É°„É™„Ç´„Ç∏„É≥'));
    it('Mixed kana converts every char h -> k', () =>
      expect(toHiragana('„Ç¢„É°„É™„Ç´„Åò„Çì')).toBe('„ÅÇ„ÇÅ„Çä„Åã„Åò„Çì'));

    describe('long vowels', () => {
      it('Converts long vowels correctly from k -> h', () =>
        expect(toHiragana('„Éê„ÉÑ„Ç¥„Éº')).toBe('„Å∞„Å§„Åî„ÅÜ'));
      it('Preserves long dash from h -> k', () =>
        expect(toKatakana('„Å∞„Å§„Ç≤„Éº„É†')).toBe('„Éê„ÉÑ„Ç≤„Éº„É†'));
      it('Preserves long dash from h -> h', () =>
        expect(toHiragana('„Å∞„Å§„Åí„Éº„ÇÄ')).toBe('„Å∞„Å§„Åí„Éº„ÇÄ'));
      it('Preserves long dash from k -> k', () =>
        expect(toKatakana('„Éê„ÉÑ„Ç≤„Éº„É†')).toBe('„Éê„ÉÑ„Ç≤„Éº„É†'));
      it('Preserves long dash from mixed -> k', () =>
        expect(toKatakana('„Éê„ÉÑ„Ç≤„Éº„É†')).toBe('„Éê„ÉÑ„Ç≤„Éº„É†'));
      it('Preserves long dash from mixed -> k', () =>
        expect(toKatakana('„ÉÜ„Çπ„Éº„Å®')).toBe('„ÉÜ„Çπ„Éº„Éà'));
      it('Preserves long dash from mixed -> h', () =>
        expect(toHiragana('„Å¶„Åô„Éº„Éà')).toBe('„Å¶„Åô„Éº„Å®'));
      it('Preserves long dash from mixed -> h', () =>
        expect(toHiragana('„Å¶„Åô„ÉºÊà∏')).toBe('„Å¶„Åô„ÉºÊà∏'));
      it('Preserves long dash from mixed -> h', () =>
        expect(toHiragana('ÊâãÂ∑£„Éº„Éà')).toBe('ÊâãÂ∑£„Éº„Å®'));
      it('Preserves long dash from mixed -> h', () =>
        expect(toHiragana('tes„Éº„Éà')).toBe('„Å¶s„Éº„Å®'));
      it('Preserves long dash from mixed -> h', () =>
        expect(toHiragana('„Éº„Éàtesu')).toBe('„Éº„Å®„Å¶„Åô'));
    });

    describe('Mixed syllabaries', () => {
      it('It passes non-katakana through when passRomaji is true k -> h', () =>
        expect(toHiragana('Â∫ßÁ¶Ö‚Äòzazen‚Äô„Çπ„Çø„Ç§„É´', { passRomaji: true })).toBe(
          'Â∫ßÁ¶Ö‚Äòzazen‚Äô„Åô„Åü„ÅÑ„Çã'
        ));

      it('It passes non-hiragana through when passRomaji is true h -> k', () =>
        expect(toKatakana('Â∫ßÁ¶Ö‚Äòzazen‚Äô„Åô„Åü„ÅÑ„Çã', { passRomaji: true })).toBe(
          'Â∫ßÁ¶Ö‚Äòzazen‚Äô„Çπ„Çø„Ç§„É´'
        ));

      it('It converts non-katakana when passRomaji is false k -> h', () =>
        expect(toHiragana('Â∫ßÁ¶Ö‚Äòzazen‚Äô„Çπ„Çø„Ç§„É´')).toBe('Â∫ßÁ¶Ö„Äå„Åñ„Åú„Çì„Äç„Åô„Åü„ÅÑ„Çã'));

      it('It converts non-hiragana when passRomaji is false h -> k', () =>
        expect(toKatakana('Â∫ßÁ¶Ö‚Äòzazen‚Äô„Åô„Åü„ÅÑ„Çã')).toBe('Â∫ßÁ¶Ö„Äå„Ç∂„Çº„É≥„Äç„Çπ„Çø„Ç§„É´'));
    });
  });

  describe('Case sensitivity', () => {
    it("cAse DoEsn'T MatTER for toHiragana()", () =>
      expect(toHiragana('aiueo')).toBe(toHiragana('AIUEO')));
    it("cAse DoEsn'T MatTER for toKatakana()", () =>
      expect(toKatakana('aiueo')).toBe(toKatakana('AIUEO')));
    it('Case DOES matter for toKana()', () => expect(toKana('aiueo')).not.toBe(toKana('AIUEO')));
  });

  describe('N edge cases', () => {
    it('Solo N', () => expect(toKana('n')).toBe('„Çì'));
    it('double N', () => expect(toKana('onn')).toBe('„Åä„Çì„Çì'));
    it('N followed by N* syllable', () => expect(toKana('onna')).toBe('„Åä„Çì„Å™'));
    it('Triple N', () => expect(toKana('nnn')).toBe('„Çì„Çì„Çì'));
    it('Triple N followed by N* syllable', () => expect(toKana('onnna')).toBe('„Åä„Çì„Çì„Å™'));
    it('Quadruple N', () => expect(toKana('nnnn')).toBe('„Çì„Çì„Çì„Çì'));
    it('nya -> „Å´„ÇÉ', () => expect(toKana('nyan')).toBe('„Å´„ÇÉ„Çì'));
    it('nnya -> „Çì„Å´„ÇÉ', () => expect(toKana('nnyann')).toBe('„Çì„Å´„ÇÉ„Çì„Çì'));
    it('nnnya -> „Çì„Å´„ÇÉ', () => expect(toKana('nnnyannn')).toBe('„Çì„Çì„Å´„ÇÉ„Çì„Çì„Çì'));
    it("n'ya -> „Çì„ÇÑ", () => expect(toKana("n'ya")).toBe('„Çì„ÇÑ'));
    it("kin'ya -> „Åç„Çì„ÇÑ", () => expect(toKana("kin'ya")).toBe('„Åç„Çì„ÇÑ'));
    it("shin'ya -> „Åó„Çì„ÇÑ", () => expect(toKana("shin'ya")).toBe('„Åó„Çì„ÇÑ'));
    it('kinyou -> „Åç„Å´„Çá„ÅÜ', () => expect(toKana('kinyou')).toBe('„Åç„Å´„Çá„ÅÜ'));
    it("kin'you -> „Åç„Çì„Çà„ÅÜ", () => expect(toKana("kin'you")).toBe('„Åç„Çì„Çà„ÅÜ'));
    it("kin'yu -> „Åç„Çì„ÇÜ", () => expect(toKana("kin'yu")).toBe('„Åç„Çì„ÇÜ'));
    it('Properly add space after "n[space]"', () =>
      expect(toKana('ichiban warui')).toBe('„ÅÑ„Å°„Å∞„Çì „Çè„Çã„ÅÑ'));
  });

  describe('Bogus 4 character sequences', () => {
    it('Non bogus sequences work', () => expect(toKana('chya')).toBe('„Å°„ÇÉ'));
    it('Bogus sequences do not work', () => expect(toKana('chyx')).toBe('chyx'));
    it('Bogus sequences do not work', () => expect(toKana('shyp')).toBe('shyp'));
    it('Bogus sequences do not work', () => expect(toKana('ltsb')).toBe('ltsb'));
  });
});

describe('Kana to Romaji', () => {
  describe('toRomaji()', () => {
    it('Convert katakana to romaji', () =>
      expect(toRomaji('„ÉØ„Éã„Ç´„Éã„ÄÄ„Ç¨„ÄÄ„Çπ„Ç¥„Ç§„ÄÄ„ÉÄ')).toBe('wanikani ga sugoi da'));

    it('Convert hiragana to romaji', () =>
      expect(toRomaji('„Çè„Å´„Åã„Å´„ÄÄ„Åå„ÄÄ„Åô„Åî„ÅÑ„ÄÄ„Å†')).toBe('wanikani ga sugoi da'));

    it('Convert mixed kana to romaji', () =>
      expect(toRomaji('„ÉØ„Éã„Ç´„Éã„ÄÄ„Åå„ÄÄ„Åô„Åî„ÅÑ„ÄÄ„Å†')).toBe('wanikani ga sugoi da'));

    it('Will convert punctuation and full-width spaces', () =>
      expect(toRomaji(JA_PUNC.join(''))).toBe(EN_PUNC.join('')));

    it('Use the upcaseKatakana flag to preserve casing. Works for katakana.', () =>
      expect(toRomaji('„ÉØ„Éã„Ç´„Éã', { upcaseKatakana: true })).toBe('WANIKANI'));

    it('Use the upcaseKatakana flag to preserve casing. Works for mixed kana.', () =>
      expect(toRomaji('„ÉØ„Éã„Ç´„Éã„ÄÄ„Åå„ÄÄ„Åô„Åî„ÅÑ„ÄÄ„Å†', { upcaseKatakana: true })).toBe(
        'WANIKANI ga sugoi da'
      ));

    it("Doesn't mangle the long dash '„Éº' or slashdot '„Éª'", () =>
      expect(toRomaji('ÁΩ∞„Ç≤„Éº„É†„Éª„Å∞„Å§„Åí„Éº„ÇÄ')).toBe('ÁΩ∞geemu/batsuge-mu'));

    it("Doesn't mangle the long dash '„Éº' or slashdot '„Éª'", () =>
      expect(toRomaji('ÁΩ∞„Ç≤„Éº„É†„Éª„Å∞„Å§„Åí„Éº„ÇÄ')).toBe('ÁΩ∞geemu/batsuge-mu'));

    it('Spaces must be manually entered', () =>
      expect(toRomaji('„Çè„Å´„Åã„Å´„Åå„Åô„Åî„ÅÑ„Å†')).not.toBe('wanikani ga sugoi da'));
  });

  describe('Test every character with toRomaji()', () => {
    describe('Hiragana input toRomaji()', () => {
      HIRA_KATA_TO_ROMA.forEach((item) => {
        const [hiragana, , romaji] = item;
        const result = toRomaji(hiragana);
        it(`${hiragana}`, () => expect(result).toBe(romaji));
      });
    });
    describe('Katakana input toRomaji()', () => {
      HIRA_KATA_TO_ROMA.forEach((item) => {
        const [, katakana, romaji] = item;
        const result = toRomaji(katakana);
        it(`${katakana}`, () => expect(result).toBe(romaji));
      });
    });
  });

  describe("double n's and double consonants", () => {
    it('Double and single n', () => expect(toRomaji('„Åç„Çì„Å´„Åè„Åæ„Çì')).toBe('kinnikuman'));
    it('N extravaganza', () => expect(toRomaji('„Çì„Çì„Å´„Çì„Å´„Çì„Å´„ÇÉ„Çì„ÇÑ„Çì')).toBe("nnninninnyan'yan"));
    it('Double consonants', () =>
      expect(toRomaji('„Åã„Å£„Å±„ÄÄ„Åü„Å£„Åü„ÄÄ„Åó„ÇÖ„Å£„Åó„ÇÖ „Å°„ÇÉ„Å£„Å°„ÇÉ„ÄÄ„ÇÑ„Å£„Å§')).toBe(
        'kappa tatta shusshu chatcha yattsu'
      ));
  });

  describe('Small kana', () => {
    it("Small tsu doesn't transliterate", () => expect(toRomaji('„Å£')).toBe(''));
    it('Small ya', () => expect(toRomaji('„ÇÉ')).toBe('ya'));
    it('Small yu', () => expect(toRomaji('„ÇÖ')).toBe('yu'));
    it('Small yo', () => expect(toRomaji('„Çá')).toBe('yo'));
    it('Small a', () => expect(toRomaji('„ÅÅ')).toBe('a'));
    it('Small i', () => expect(toRomaji('„ÅÉ')).toBe('i'));
    it('Small u', () => expect(toRomaji('„ÅÖ')).toBe('u'));
    it('Small e', () => expect(toRomaji('„Åá')).toBe('e'));
    it('Small o', () => expect(toRomaji('„Åâ')).toBe('o'));
  });

  describe('Apostrophes in ambiguous consonant vowel combos', () => {
    it('„Åä„Çì„Çà„Åø', () => expect(toRomaji('„Åä„Çì„Çà„Åø')).toBe("on'yomi"));
    it('„Çì„Çà „Çì„ÅÇ „Çì„ÇÜ', () => expect(toRomaji('„Çì„Çà „Çì„ÅÇ „Çì„ÇÜ')).toBe("n'yo n'a n'yu"));
  });
});

describe('stripOkurigana', () => {
  it('passes default parameter tests', () => {
    expect(stripOkurigana('„Åµ„Åµ„Éï„Éï')).toBe('„Åµ„Åµ„Éï„Éï');
    expect(stripOkurigana('„Åµa„Åµb„Éïc„Éï')).toBe('„Åµa„Åµb„Éïc„Éï');
    expect(stripOkurigana('„ÅäËÖπ')).toBe('„ÅäËÖπ');
    expect(stripOkurigana('Ë∏è„ÅøËæº„ÇÄ')).toBe('Ë∏è„ÅøËæº');
    expect(stripOkurigana('„ÅäÁ•ù„ÅÑ')).toBe('„ÅäÁ•ù');
    expect(stripOkurigana('Á≤ò„Çä')).toBe('Á≤ò');
    expect(stripOkurigana('„Äú„ÅÑÊµ∑Ëªç„ÅÑ„ÄÅ„ÄÇ')).toBe('„Äú„ÅÑÊµ∑Ëªç„ÄÅ„ÄÇ');
  });
  it('strips all kana when passed optional config', () => {
    expect(stripOkurigana('„ÅäËÖπ', { all: true })).toBe('ËÖπ');
    expect(stripOkurigana('Ë∏è„ÅøËæº„ÇÄ', { all: true })).toBe('Ë∏èËæº');
    expect(stripOkurigana('„ÅäÁ•ù„ÅÑ', { all: true })).toBe('Á•ù');
    expect(stripOkurigana('„ÅäË∏è„ÅøËæº„ÇÄ', { all: true })).toBe('Ë∏èËæº');
    expect(stripOkurigana('„Äú„ÅÑÊµ∑Ëªç„ÅÑ„ÄÅ„ÄÇ', { all: true })).toBe('„ÄúÊµ∑Ëªç„ÄÅ„ÄÇ');
  });
});

describe('tokenize', () => {
  it('passes default parameter tests', () => {
    expect(tokenize('„Åµ„Åµ')).toEqual(['„Åµ„Åµ']);
    expect(tokenize('„Éï„Éï')).toEqual(['„Éï„Éï']);
    expect(tokenize('„Åµ„Åµ„Éï„Éï')).toEqual(['„Åµ„Åµ', '„Éï„Éï']);
    expect(tokenize('ÈòÆÂí∏')).toEqual(['ÈòÆÂí∏']);
    expect(tokenize('ÊÑü„Åò')).toEqual(['ÊÑü', '„Åò']);
    expect(tokenize('ÁßÅ„ÅØÊÇ≤„Åó„ÅÑ')).toEqual(['ÁßÅ', '„ÅØ', 'ÊÇ≤', '„Åó„ÅÑ']);
    expect(tokenize('what the...ÁßÅ„ÅØ„ÄåÊÇ≤„Åó„ÅÑ„Äç„ÄÇ')).toEqual([
      'what the...',
      'ÁßÅ',
      '„ÅØ',
      '„Äå',
      'ÊÇ≤',
      '„Åó„ÅÑ',
      '„Äç„ÄÇ',
    ]);
  });
});

describe('Event listener helpers', () => {
  document.body.innerHTML = `
      <div>
        <input id="ime" type="text" />
        <textarea id="ime2"></textarea>
        <input id="ime3" type="text" />
        <input class="has-no-id" type="text" />
      </div>
    `;
  const inputField1 = document.querySelector('#ime');
  const inputField2 = document.querySelector('#ime2');
  const inputField3 = document.querySelector('.has-no-id');

  it('fails safely with console warning when invalid element passed', () => {
    expect(() => bind()).not.toThrow();
    expect(() => bind('nerp')).not.toThrow();
    expect(() => unbind()).not.toThrow();
    expect(() => unbind('nerp')).not.toThrow();
  });

  it('adds onInput event listener', () => {
    bind(inputField1);
    inputField1.value = 'wanakana';
    simulant.fire(inputField1, 'input');
    expect(inputField1.value).toEqual('„Çè„Å™„Åã„Å™');
    expect(inputField1.getAttribute('data-wanakana-id')).toBeDefined();
  });

  it('forces autocapitalize "none"', () => {
    expect(inputField1.autocapitalize).toEqual('none');
  });

  it('removes onInput event listener', () => {
    unbind(inputField1);
    inputField1.value = 'fugu';
    simulant.fire(inputField1, 'input');
    expect(inputField1.value).toEqual('fugu');
    expect(inputField1.getAttribute('data-wanakana-id')).toBeNull();
  });

  it('forces IMEMode true if option not specified', () => {
    bind(inputField1);
    inputField1.value = "n'";
    simulant.fire(inputField1, 'input');
    expect(inputField1.value).toEqual('„Çì');
    unbind(inputField1);
  });

  it('should handle an options object', () => {
    bind(inputField1, { useObsoleteKana: true });
    inputField1.value = 'wiweWIWEwo';
    simulant.fire(inputField1, 'input');
    expect(inputField1.value).toEqual('„Çê„Çë„É∞„É±„Çí');
    unbind(inputField1);
  });

  it('should allow conversion type selection', () => {
    bind(inputField1, { IMEMode: TO_KANA_METHODS.KATAKANA });
    bind(inputField2, { IMEMode: TO_KANA_METHODS.HIRAGANA });
    inputField1.value = 'amerika';
    inputField2.value = 'KURO';
    simulant.fire(inputField1, 'input');
    simulant.fire(inputField2, 'input');
    expect(inputField1.value).toEqual('„Ç¢„É°„É™„Ç´');
    expect(inputField2.value).toEqual('„Åè„Çç');
    unbind(inputField1);
    unbind(inputField2);
  });

  it('should instantiate separate onInput bindings', () => {
    bind(inputField1, {});
    bind(inputField2, { useObsoleteKana: true });
    inputField1.value = 'WIWEwiwe';
    inputField2.value = 'WIWEwiwe';
    simulant.fire(inputField1, 'input');
    simulant.fire(inputField2, 'input');
    expect(inputField1.value).toEqual('„Ç¶„Ç£„Ç¶„Çß„ÅÜ„ÅÉ„ÅÜ„Åá');
    expect(inputField2.value).toEqual('„É∞„É±„Çê„Çë');
    unbind(inputField1);
    unbind(inputField2);
  });

  it('should keep track of separate onInput bindings if element has no id', () => {
    bind(inputField2);
    bind(inputField3);
    inputField2.value = 'wana';
    inputField3.value = 'kana';
    simulant.fire(inputField2, 'input');
    simulant.fire(inputField3, 'input');
    expect(inputField2.value).toEqual('„Çè„Å™');
    expect(inputField3.value).toEqual('„Åã„Å™');
    unbind(inputField2);
    unbind(inputField3);
  });

  it('ignores double consonants following composeupdate', () => {
    bind(inputField1);
    inputField1.value = '„ÅãÔΩî';
    simulant.fire(inputField1, 'input');
    expect(inputField1.value).toEqual('„ÅãÔΩî');
    inputField1.value = '„ÅãÔΩîÔΩî';
    // have to fake it... no compositionupdate in jsdom
    inputField1.dispatchEvent(
      new CustomEvent('compositionupdate', {
        bubbles: true,
        cancellable: true,
        detail: { data: '„ÅãÔΩîÔΩî' },
      })
    );
    simulant.fire(inputField1, 'input');
    expect(inputField1.value).toEqual('„ÅãÔΩîÔΩî');
    unbind(inputField1);
  });

  it('should handle nonascii', () => {
    bind(inputField1);
    inputField1.value = 'ÔΩàÔΩâÔΩíÔΩèÔΩâ';
    simulant.fire(inputField1, 'input');
    expect(inputField1.value).toEqual('„Å≤„Çç„ÅÑ');
    // skips setting value if conversion would be the same
    inputField1.value = '„Åã„Çì„Åò';
    simulant.fire(inputField1, 'input');
    expect(inputField1.value).toEqual('„Åã„Çì„Åò');
    unbind(inputField1);
  });

  it('should keep the cursor at the correct position even after conversion', () => {
    bind(inputField1);
    const inputValue = 'sentaku';
    const expected = '„Åõ„Çì„Åü„Åè';
    const expectedCursorPositions = [0, 1, 1, 2, 3, 3, 4, 4];
    for (let index = 0; index < expected.length; index += 1) {
      inputField1.value = inputValue;
      inputField1.setSelectionRange(index, index);
      simulant.fire(inputField1, 'input');
      expect(inputField1.value).toEqual(expected);
      expect(inputField1.selectionStart).toBe(expectedCursorPositions[index]);
    }
    unbind(inputField1);
  });
  it('should keep the cursor at the correct position even after conversion', () => {
    bind(inputField1);
    const inputValue = 'senshitaku';
    const expected = '„Åõ„Çì„Åó„Åü„Åè';
    const expectedCursorPositions = [0, 1, 1, 2, 3, 3, 3, 4, 4, 5, 5];
    for (let index = 0; index < expected.length; index += 1) {
      inputField1.value = inputValue;
      inputField1.setSelectionRange(index, index);
      simulant.fire(inputField1, 'input');
      expect(inputField1.value).toEqual(expected);
      expect(inputField1.selectionStart).toBe(expectedCursorPositions[index]);
    }
    unbind(inputField1);
  });
});

describe('IMEMode', () => {
  /**
   * Simulate real typing by calling the function on every character in sequence
   * @param  {String} input
   * @param  {Object} options
   * @return {String} converted romaji as kana
   */
  function testTyping(input, options) {
    let pos = 1;
    let text = input;
    const len = text.length;
    // console.log(`--${text}--`);
    while (pos <= len) {
      let buffer = text.slice(0, pos);
      const rest = text.slice(pos);
      buffer = toKana(buffer, options);
      // console.log(`${pos}:${buffer} <-${rest}`);
      text = buffer + rest;
      pos += 1;
    }
    return text;
  }

  it("Without IME mode, solo n's are transliterated.", () => expect(toKana('n')).toBe('„Çì'));
  it("Without IME mode, double n's are transliterated.", () => expect(toKana('nn')).toBe('„Çì„Çì'));

  it("With IME mode, solo n's are not transliterated.", () =>
    expect(testTyping('n', { IMEMode: true })).toBe('n'));
  it("With IME mode, solo n's are not transliterated, even when cursor has been relocated.", () =>
    // pretending k,a,n -> „Åã„Çì| then moving curosr to „Åã|„Çì and typing 'n'
    expect(testTyping('„Åãn„Çì', { IMEMode: true })).toBe('„Åãn„Çì'));

  // NOTE: I think we need to store cursor location onInput, diff the text to remove any existing Japanese
  // before it is sent to toKana(), rather than our current processing of ALL text through toKana
  // then we can convert the new input as it is entered whilst
  // re-applying the previous existing text around it when setting the input field value on conversion
  // (all while setting the correct cursor location again :/ )
  it("With IME mode, solo n's are not transliterated, even when cursor has been relocated.", () =>
    // pretending k,a,n,a -> „Åã„Å™| then moving curosr to „Åã|„Å™ and typing 'n,y'
    expect(testTyping('„Åãny„Å™', { IMEMode: true })).toBe('„Åãny„Å™'));
  it("With IME mode, double n's are transliterated.", () =>
    expect(testTyping('nn', { IMEMode: true })).toBe('„Çì'));
  it('With IME mode, n + space are transliterated.', () =>
    expect(testTyping('n ', { IMEMode: true })).toBe('„Çì'));
  it("With IME mode, n + ' are transliterated.", () =>
    expect(testTyping("n'", { IMEMode: true })).toBe('„Çì'));
  it('With IME mode, ni.', () => expect(testTyping('ni', { IMEMode: true })).toBe('„Å´'));

  it('kan', () => expect(testTyping('kan', { IMEMode: true })).toBe('„Åãn'));
  it('kanp', () => expect(testTyping('kanp', { IMEMode: true })).toBe('„Åã„Çìp'));
  it('kanpai!', () => expect(testTyping('kanpai', { IMEMode: true })).toBe('„Åã„Çì„Å±„ÅÑ'));
  it('nihongo', () => expect(testTyping('nihongo', { IMEMode: true })).toBe('„Å´„Åª„Çì„Åî'));

  it("y doesn't count as a consonant for IME", () =>
    expect(testTyping('ny', { IMEMode: true })).toBe('ny'));
  it('nya works as expected', () => expect(testTyping('nya', { IMEMode: true })).toBe('„Å´„ÇÉ'));

  it("With IME mode, solo N's are not transliterated - katakana.", () =>
    expect(testTyping('N', { IMEMode: true })).toBe('N'));
  it("With IME mode, double N's are transliterated - katakana.", () =>
    expect(testTyping('NN', { IMEMode: true })).toBe('„É≥'));
  it('With IME mode, NI - katakana.', () => expect(testTyping('NI', { IMEMode: true })).toBe('„Éã'));
  it('With IME mode - KAN - katakana', () =>
    expect(testTyping('KAN', { IMEMode: true })).toBe('„Ç´N'));
  it('With IME mode - NIHONGO - katakana', () =>
    expect(testTyping('NIHONGO', { IMEMode: true })).toBe('„Éã„Éõ„É≥„Ç¥'));
});

describe('Options', () => {
  describe('useObsoleteKana', () => {
    describe('toKana', () => {
      it('useObsoleteKana is false by default', () => expect(toKana('wi')).toBe('„ÅÜ„ÅÉ'));
      it('wi = „Çê (when useObsoleteKana is true)', () =>
        expect(toKana('wi', { useObsoleteKana: true })).toBe('„Çê'));
      it('we = „Çë (when useObsoleteKana is true)', () =>
        expect(toKana('we', { useObsoleteKana: true })).toBe('„Çë'));
      it('WI = „É∞ (when useObsoleteKana is true)', () =>
        expect(toKana('WI', { useObsoleteKana: true })).toBe('„É∞'));
      it('WE = „É± (when useObsoleteKana is true)', () =>
        expect(toKana('WE', { useObsoleteKana: true })).toBe('„É±'));
    });

    describe('toHiragana', () => {
      it('useObsoleteKana is false by default', () => expect(toHiragana('wi')).toBe('„ÅÜ„ÅÉ'));
      it('wi = „Çê (when useObsoleteKana is true)', () =>
        expect(toHiragana('wi', { useObsoleteKana: true })).toBe('„Çê'));
      it('we = „Çë (when useObsoleteKana is true)', () =>
        expect(toHiragana('we', { useObsoleteKana: true })).toBe('„Çë'));
      it('wi = „ÅÜ„ÅÉ when useObsoleteKana is false', () =>
        expect(toHiragana('wi', { useObsoleteKana: false })).toBe('„ÅÜ„ÅÉ'));
    });

    describe('toKataKana', () => {
      it('wi = „Ç¶„Ç£ when useObsoleteKana is false', () =>
        expect(toKatakana('WI', { useObsoleteKana: false })).toBe('„Ç¶„Ç£'));
      it('WI = „É∞ (when useObsoleteKana is true)', () =>
        expect(toKatakana('wi', { useObsoleteKana: true })).toBe('„É∞'));
      it('WE = „É± (when useObsoleteKana is true)', () =>
        expect(toKatakana('we', { useObsoleteKana: true })).toBe('„É±'));
    });
  });
});
